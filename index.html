<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arjun-G-Ravi/chat-GPT-2 — Mobile</title>
    <script type="importmap">
        { "imports": { "@mlc-ai/web-llm": "https://esm.run/@mlc-ai/web-llm" } }
    </script>
    <style>
        :root { --apple-blue: #007AFF; --glass: rgba(255, 255, 255, 0.7); }
        body {
            margin: 0; padding: 0; height: 100vh;
            background: linear-gradient(160deg, #a2c2e6 0%, #d4e1f5 100%);
            font-family: -apple-system, system-ui, sans-serif;
            display: flex; justify-content: center; align-items: center;
        }
        /* Apple Glass Container */
        .app-card {
            width: 95%; max-width: 450px; height: 90vh;
            background: var(--glass); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255,255,255,0.4); border-radius: 38px;
            display: flex; flex-direction: column; overflow: hidden;
            box-shadow: 0 20px 50px rgba(0,0,0,0.1);
        }
        header { padding: 14px 20px; display:flex; justify-content:space-between; align-items:center; gap:12px; border-bottom: 0.5px solid rgba(0,0,0,0.1); }
        h1 { margin: 0; font-size: 16px; font-weight: 600; color: #1d1d1f; }
        .status { font-size: 12px; color: #444; opacity: 0.9; text-align: right; }
        .controls { display:flex; gap:8px; align-items:center; }
        .btn-clear { background: transparent; border: 1px solid rgba(0,0,0,0.06); padding: 6px 10px; border-radius: 12px; font-size: 12px; cursor: pointer; }
        
        #chat-box { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        
        /* Message Bubbles */
        .msg { max-width: 80%; padding: 12px 16px; border-radius: 20px; font-size: 15px; line-height: 1.4; animation: spring 0.4s ease-out; word-break: break-word; white-space: pre-wrap; }
        .user { align-self: flex-end; background: var(--apple-blue); color: white; border-bottom-right-radius: 4px; }
        .ai { align-self: flex-start; background: rgba(255,255,255,0.9); color: #1d1d1f; border-bottom-left-radius: 4px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }

        /* Thinking Animation */
        .thinking { display: none; padding: 12px; }
        .dots { display: flex; gap: 4px; }
        .dot { width: 8px; height: 8px; background: #8e8e93; border-radius: 50%; animation: pulse 1.4s infinite; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }

        .input-bar { padding: 12px 15px; background: rgba(255,255,255,0.5); display: flex; gap: 10px; align-items: center; }
        input { flex: 1; border: none; padding: 10px 14px; border-radius: 20px; background: white; outline: none; font-size: 15px; }
        button { background: var(--apple-blue); color: white; border: none; width: 36px; height: 36px; border-radius: 50%; font-size: 18px; cursor: pointer; transition: transform 0.2s; }
        button:active { transform: scale(0.9); }
        .small { font-size: 12px; color: #666; margin-left: 8px; }

        .btn-stop { background: #ff3b30; width: auto; padding: 6px 10px; height: auto; border-radius: 12px; font-size: 13px; display: inline-block; color: white; border: none; cursor: pointer; }
        .btn-stop[disabled] { opacity: 0.5; cursor: default; }

        @keyframes pulse { 0%, 100% { opacity: 0.3; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1); } }
        @keyframes spring { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

<div class="app-card">
    <header>
        <h1>Arjun-G-Ravi/chat-GPT-2 — Mobile</h1>
        <div class="controls">
            <div class="status" id="status">Initializing...</div>
            <button id="clearBtn" class="btn-clear" title="Clear session">Clear session</button>
        </div>
    </header>

    <div id="chat-box">
        <div class="msg ai">Hello! I'm optimized for phones. Ask me anything.</div>
    </div>
    
    <div id="thinking" class="thinking" aria-hidden="true">
        <div class="dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </div>

    <div class="input-bar">
        <input type="text" id="userInput" placeholder="Message">
        <button id="sendBtn">↑</button>
        <button id="stopBtn" class="btn-stop" disabled title="Stop generation">Stop</button>
        <div class="small" id="charsRemaining"></div>
    </div>
</div>

<script type="module">
    // Main thread: UI, IndexedDB, telemetry and worker messaging
    const MODEL_DEFAULT = "Arjun-G-Ravi/chat-GPT-2";
    const MAX_INPUT_CHARS = 800;
    const SUMMARIZE_AFTER = 6;
    const DB_NAME = 'chatbot-db';
    const DB_STORE = 'sessions';
    const SESSION_STORE_KEY = 'latest_session';
    const TELEMETRY_KEY = 'telemetry';
    const AUTO_UNLOAD_AFTER_RUNS = 20; // auto-unload engine in worker after N runs to avoid memory bloat

    // UI
    const chatBox = document.getElementById('chat-box');
    const thinking = document.getElementById('thinking');
    const input = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const charsRemainingEl = document.getElementById('charsRemaining');
    const clearBtn = document.getElementById('clearBtn');

    // State
    let history = [];
    let summary = "The start of a fresh conversation.";
    let assistantCountSinceSummary = 0;
    let telemetry = { initTimes: [], avgCharsPerSec: [], memorySamples: [] };
    let worker = null;
    let workerReady = false;
    let pendingInit = null;
    let activeRun = null; // {runId, resolveDone}
    let runCounter = 0; // counts completed runs since last unload/restart

    // IndexedDB helpers (same as before + delete)
    function openDB() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = () => {
                const db = req.result;
                if (!db.objectStoreNames.contains(DB_STORE)) {
                    db.createObjectStore(DB_STORE);
                }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }
    async function dbPut(key, value) {
        try {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(DB_STORE, 'readwrite');
                const store = tx.objectStore(DB_STORE);
                store.put(value, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        } catch (e) { console.warn('dbPut error', e); }
    }
    async function dbGet(key) {
        try {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(DB_STORE, 'readonly');
                const store = tx.objectStore(DB_STORE);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        } catch (e) { console.warn('dbGet error', e); }
    }
    async function dbDelete(key) {
        try {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(DB_STORE, 'readwrite');
                const store = tx.objectStore(DB_STORE);
                const req = store.delete(key);
                req.onsuccess = () => resolve();
                req.onerror = () => reject(req.error);
            });
        } catch (e) { console.warn('dbDelete error', e); }
    }

    // Restore session
    (async function restoreSession() {
        try {
            const s = await dbGet(SESSION_STORE_KEY);
            if (s) {
                history = s.history || [];
                summary = s.summary || summary;
                assistantCountSinceSummary = s.assistantCountSinceSummary || assistantCountSinceSummary;
                chatBox.innerHTML = '';
                for (const m of history) {
                    const div = document.createElement('div');
                    div.className = `msg ${m.role === 'user' ? 'user' : 'ai'}`;
                    div.innerText = m.content;
                    chatBox.appendChild(div);
                }
                chatBox.scrollTop = chatBox.scrollHeight;
            }
            const t = await dbGet(TELEMETRY_KEY);
            if (t) { telemetry = t; }
            updateStatus('Idle');
        } catch (e) {
            console.warn('restoreSession failed', e);
            updateStatus('Idle');
        }
    })();

    function updateStatus(text) { statusEl.innerText = text; }

    // Device memory sample
    function sampleMemory() {
        const mem = {
            deviceMemoryGB: navigator.deviceMemory || null,
            performanceMemory: performance?.memory ? {
                jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                totalJSHeapSize: performance.memory.totalJSHeapSize,
                usedJSHeapSize: performance.memory.usedJSHeapSize
            } : null,
            time: Date.now()
        };
        telemetry.memorySamples.push(mem);
        if (telemetry.memorySamples.length > 50) telemetry.memorySamples.shift();
        dbPut(TELEMETRY_KEY, telemetry).catch(()=>{});
    }

    // Worker setup
    function ensureWorker() {
        if (worker) return;
        // Worker file is mlc-worker.js located next to index.html
        worker = new Worker('mlc-worker.js', { type: 'module' });

        worker.onmessage = (ev) => {
            const m = ev.data;
            if (m.type === 'ready') {
                workerReady = true;
                if (pendingInit) {
                    pendingInit.resolve(m.initTime);
                    pendingInit = null;
                }
                telemetry.initTimes.push(m.initTime);
                if (telemetry.initTimes.length > 20) telemetry.initTimes.shift();
                dbPut(TELEMETRY_KEY, telemetry).catch(()=>{});
                updateStatus('Model ready (worker)');
                sampleMemory();
            } else if (m.type === 'unloaded') {
                // engine inside worker unloaded — will be re-initialized on next initEngine()
                workerReady = false;
                updateStatus('Engine unloaded (worker)');
            } else if (m.type === 'token') {
                if (activeRun && activeRun.runId === m.runId) {
                    activeRun.onToken && activeRun.onToken(m.token);
                }
            } else if (m.type === 'done') {
                if (activeRun && activeRun.runId === m.runId) {
                    activeRun.resolveDone && activeRun.resolveDone();
                    activeRun = null;
                }
            } else if (m.type === 'error') {
                // show the error message to the user and try to recover
                console.error('Worker error:', m.error);
                updateStatus('Worker error: ' + (m.error || 'unknown'));
                if (activeRun && activeRun.runId === m.runId) {
                    activeRun.rejectDone && activeRun.rejectDone(m.error || 'worker-error');
                    activeRun = null;
                }
                // Try to recover automatically by restarting worker (best-effort)
                setTimeout(async () => {
                    try {
                        await restartWorker();
                        updateStatus('Worker restarted');
                    } catch (e) {
                        console.warn('restartWorker failed', e);
                    }
                }, 400);
            } else if (m.type === 'log') {
                console.log('worker:', m.msg);
            } else if (m.type === 'shutdown') {
                // worker confirmed shutdown
                console.log('worker shutdown confirmed');
            }
        };

        worker.onerror = (e) => {
            console.error('Worker onerror', e);
            updateStatus('Worker error');
            // attempt restart
            setTimeout(() => restartWorker().catch(()=>{}), 300);
        };
    }

    // Initialize model in worker
    async function initEngine(modelId = MODEL_DEFAULT) {
        ensureWorker();
        if (workerReady) return;
        updateStatus('Loading model (worker)...');
        pendingInit = {};
        pendingInit.promise = new Promise((resolve, reject) => {
            pendingInit.resolve = resolve;
            pendingInit.reject = reject;
        });
        worker.postMessage({ type: 'init', modelId });
        const initTime = await pendingInit.promise;
        return initTime;
    }

    // Request run (streaming) through worker with automatic retry once
    async function runWorkerChat(messages, opts = {}, onToken) {
        ensureWorker();
        if (!workerReady) {
            await initEngine();
        }

        // If previous run exists, abort it first
        if (activeRun) {
            worker.postMessage({ type: 'abort', runId: activeRun.runId });
            await new Promise(r => setTimeout(r, 40));
        }

        const runId = `r-${Date.now()}-${Math.floor(Math.random()*1000)}`;
        return new Promise((resolve, reject) => {
            let resolved = false;
            activeRun = {
                runId,
                onToken,
                resolveDone: () => { if (!resolved) { resolved = true; resolve(); } },
                rejectDone: (err) => { if (!resolved) { resolved = true; reject(err); } }
            };
            try {
                worker.postMessage({ type: 'run', runId, messages, opts });
            } catch (e) {
                activeRun = null;
                reject(e);
            }
        }).catch(async (err) => {
            // Try one recovery attempt: restart worker and retry once
            console.warn('runWorkerChat failed, attempting restart...', err);
            try {
                await restartWorker();
                // retry once
                return runWorkerChat(messages, opts, onToken);
            } catch (err2) {
                throw err2;
            }
        });
    }

    // Summarize via worker
    async function runWorkerSummarize(messages, opts = {}, onToken) {
        ensureWorker();
        if (!workerReady) await initEngine();
        const runId = `s-${Date.now()}-${Math.floor(Math.random()*1000)}`;
        return new Promise((resolve, reject) => {
            if (activeRun) {
                worker.postMessage({ type: 'abort', runId: activeRun.runId });
            }
            activeRun = {
                runId,
                onToken: onToken,
                resolveDone: resolve,
                rejectDone: reject
            };
            worker.postMessage({ type: 'summarize', runId, messages, opts });
        }).catch(async (err) => {
            console.warn('runWorkerSummarize failed, restarting worker...', err);
            await restartWorker();
            return runWorkerSummarize(messages, opts, onToken);
        });
    }

    // Ask worker to unload the model (keep worker alive)
    function unloadEngineInWorker() {
        if (!worker) return;
        try {
            worker.postMessage({ type: 'unload' });
            // mark workerReady false; 'unloaded' will also come via message
            workerReady = false;
            updateStatus('Unloading engine (worker)...');
        } catch (e) {
            console.warn('unloadEngineInWorker failed', e);
        }
    }

    // Abort active run
    function abortActiveRun() {
        if (activeRun && worker) {
            worker.postMessage({ type: 'abort', runId: activeRun.runId });
            updateStatus('Aborted');
        }
    }

    // Restart worker (shutdown -> recreate)
    async function restartWorker() {
        try {
            if (worker) {
                try { worker.postMessage({ type: 'shutdown' }); } catch (e) {}
                worker.terminate();
            }
        } catch (e) { console.warn('terminate error', e); }
        worker = null;
        workerReady = false;
        pendingInit = null;
        activeRun = null;
        // small delay before recreating
        await new Promise(r => setTimeout(r, 150));
        ensureWorker();
        await initEngine();
    }

    // Shutdown worker
    async function shutdownWorker() {
        if (!worker) return;
        try {
            worker.postMessage({ type: 'shutdown' });
        } catch (e) {}
        worker.terminate();
        worker = null;
        workerReady = false;
    }

    // Efficient append helpers
    function appendMessage(role, text) {
        const div = document.createElement('div');
        div.className = `msg ${role === 'user' ? 'user' : 'ai'}`;
        div.innerText = text;
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return div;
    }
    function appendAiPlaceholderNode() {
        const div = document.createElement('div');
        div.className = 'msg ai';
        const tn = document.createTextNode('');
        div.appendChild(tn);
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return { div, tn };
    }

    // Save session
    async function persistSession() {
        const s = { history, summary, assistantCountSinceSummary, savedAt: Date.now() };
        await dbPut(SESSION_STORE_KEY, s).catch(e => console.warn('persistSession failed', e));
    }

    // Summarize history (via worker)
    async function summarizeHistory() {
        updateStatus('Summarizing...');
        const messages = [
            { role: "system", content: "You are a concise summarization assistant. Produce a short summary of the conversation focusing on facts and user intent." },
            { role: "user", content: `Summarize the following conversation briefly:\n\n${history.map(h => `${h.role.toUpperCase()}: ${h.content}`).join('\n\n')}` }
        ];
        let newSummary = '';
        try {
            await runWorkerSummarize(messages, { max_new_tokens: 128, temperature: 0.1 }, (chunk) => {
                newSummary += chunk;
            });
            if (newSummary.trim()) {
                summary = newSummary.trim();
                // keep only last 1-2 exchanges + summary to reduce context
                history = history.slice(-2);
                assistantCountSinceSummary = 0;
                await persistSession();
                updateStatus('Summarized');
            } else {
                updateStatus('Idle');
            }
        } catch (e) {
            console.warn('summarizeHistory failed', e);
            updateStatus('Idle');
        }
    }

    // Input truncation UI
    function updateCharsRemaining() {
        const remaining = Math.max(0, MAX_INPUT_CHARS - (input.value || '').length);
        charsRemainingEl.innerText = `${remaining} chars`;
    }
    input.addEventListener('input', updateCharsRemaining);
    updateCharsRemaining();

    // UI helper to set run state
    function setRunState(running) {
        sendBtn.disabled = running;
        stopBtn.disabled = !running;
    }

    // Main chat flow using worker
    async function runChat() {
        let text = (input.value || '').trim();
        if (!text) return;
        if (text.length > MAX_INPUT_CHARS) {
            text = text.slice(0, MAX_INPUT_CHARS);
            input.value = text;
            updateCharsRemaining();
            appendMessage('ai', '[Note] Your input was truncated to fit limits.');
        }
        appendMessage('user', text);
        input.value = '';
        updateCharsRemaining();
        thinking.style.display = 'block';
        updateStatus('Thinking (worker)...');
        setRunState(true);

        try {
            // ensure worker + model ready
            await initEngine();

            // prepare messages (aggressively small)
            const windowMsgs = [
                { role: "system", content: `Context summary: ${summary}` },
                ...history.slice(-2), // keep it tiny
                { role: "user", content: text }
            ];

            // placeholder
            const { div: aiDiv, tn: textNode } = appendAiPlaceholderNode();
            let fullReply = '';
            const start = performance.now();

            // stream; note runWorkerChat retries once on failure
            await runWorkerChat(windowMsgs, { max_new_tokens: 160, temperature: 0.2 }, (chunk) => {
                fullReply += chunk;
                textNode.nodeValue = fullReply;
                chatBox.scrollTop = chatBox.scrollHeight;
            });

            const durationSec = Math.max((performance.now() - start) / 1000, 0.0001);
            const charsPerSec = (fullReply.length) / durationSec;
            telemetry.avgCharsPerSec.push(charsPerSec);
            if (telemetry.avgCharsPerSec.length > 50) telemetry.avgCharsPerSec.shift();
            dbPut(TELEMETRY_KEY, telemetry).catch(()=>{});

            // update history and persist
            history.push({ role: 'user', content: text }, { role: 'assistant', content: fullReply });
            if (history.length > 8) history = history.slice(-8);
            assistantCountSinceSummary++;
            await persistSession();

            runCounter++;
            // Auto-unload engine in worker after threshold reached to reduce memory bloat
            if (runCounter >= AUTO_UNLOAD_AFTER_RUNS) {
                runCounter = 0;
                // unload asynchronously, don't block UI
                setTimeout(() => {
                    unloadEngineInWorker();
                }, 80);
            }

            // background summarization
            if (assistantCountSinceSummary >= SUMMARIZE_AFTER) {
                summarizeHistory().catch(e => console.warn('background summarize failed', e));
            }

            updateStatus('Idle');
        } catch (err) {
            console.error('Generation error:', err);
            appendMessage('ai', "Error generating reply. Attempting to recover...");
            updateStatus('Error');
            // best-effort: restart worker so next attempt is fresh
            try {
                await restartWorker();
                appendMessage('ai', "[Recovery] Worker restarted. Please try again.");
            } catch (e) {
                appendMessage('ai', "[Recovery] Restart failed. Reload the page.");
            }
        } finally {
            thinking.style.display = 'none';
            setRunState(false);
        }
    }

    sendBtn.onclick = runChat;
    input.onkeypress = (e) => { if (e.key === 'Enter') runChat(); };

    // Stop button: abort active generation
    stopBtn.addEventListener('click', () => {
        abortActiveRun();
        setRunState(false);
        thinking.style.display = 'none';
    });

    // Clear session button (improved)
    clearBtn.addEventListener('click', async () => {
        if (!confirm('Clear current session and local summary?')) return;
        // Abort active run, shutdown worker, clear data from IndexedDB
        try {
            abortActiveRun();
            if (worker) {
                try { worker.postMessage({ type: 'shutdown' }); } catch (e) {}
                worker.terminate();
            }
        } catch (e) { console.warn('clear: abort/terminate failed', e); }
        worker = null;
        workerReady = false;
        pendingInit = null;
        activeRun = null;

        // reset session state
        history = [];
        summary = "The start of a fresh conversation.";
        assistantCountSinceSummary = 0;
        chatBox.innerHTML = '';
        appendMessage('ai', "Session cleared. Hello! Ask me anything.");

        // remove persisted keys
        try {
            await dbDelete(SESSION_STORE_KEY);
            await dbDelete(TELEMETRY_KEY);
        } catch (e) { console.warn('clear db delete failed', e); }
        updateStatus('Idle');
    });

    // Abort active generation on unload or user navigation
    window.addEventListener('beforeunload', async () => {
        try { await persistSession(); await dbPut(TELEMETRY_KEY, telemetry); } catch(e){}
        abortActiveRun();
        try { await shutdownWorker(); } catch (e) {}
    });

    // Debug shortcut
    window.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === 'm') {
            console.log('Telemetry:', telemetry);
            alert(`Telemetry sample: initTimes=${telemetry.initTimes.slice(-3).map(v=>Math.round(v))}ms, avgCPS=${(telemetry.avgCharsPerSec||[]).slice(-3).map(v=>Math.round(v))}`);
        }
    });

    // Device hint
    (function deviceHint() {
        const dm = navigator.deviceMemory || 'unknown';
        const gpu = !!navigator.gpu;
        updateStatus(`Idle • deviceMemory=${dm}GB • webgpu=${gpu ? 'yes' : 'no'}`);
    })();

</script>
</body>
</html>
