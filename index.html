<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Horde Shooter: Zoomed & Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial Black', sans-serif; }
        #ui { position: absolute; top: 10px; width: 100%; text-align: center; color: white; font-size: 28px; pointer-events: none; z-index: 5; }
        #menu { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 10; }
        .btn { background: #00ff88; color: #000; padding: 20px 40px; border: none; border-radius: 50px; font-weight: bold; cursor: pointer; font-size: 20px; }
        canvas { display: block; touch-action: none; }
    </style>
</head>
<body>
    <div id="ui">ARMY: <span id="count">1</span> | GOLD: <span id="gold">0</span></div>
    <div id="menu">
        <h1 style="color:#00ff88">READY?</h1>
        <button class="btn" onclick="startGame()">START RUN</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CORE SETTINGS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        // ZOOM FIX: Lower FOV (50) makes it look closer/zoomed in
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS & ENVIRONMENT ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const pLight = new THREE.PointLight(0x00ff88, 1, 50);
        scene.add(pLight);

        // Grid floor for visual speed reference
        const grid = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
        grid.position.y = 0.01;
        scene.add(grid);

        // --- GAME STATE ---
        let gameActive = false;
        let gold = 0;
        let units = [], enemies = [], bullets = [], gates = [];
        let playerX = 0;
        let lastZ = 0;

        // Shared Geometry (Optimization)
        const unitGeo = new THREE.CapsuleGeometry(0.18, 0.4, 4, 6);
        const allyMat = new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x002244 });
        const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
        const bulletGeo = new THREE.SphereGeometry(0.08, 4, 4);
        const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        window.startGame = () => {
            document.getElementById('menu').style.display = 'none';
            gameActive = true;
            spawnAlly(0);
        };

        function spawnAlly(z) {
            const m = new THREE.Mesh(unitGeo, allyMat);
            m.position.set(playerX, 0.5, z);
            scene.add(m);
            units.push(m);
        }

        function createEnemy(z) {
            const m = new THREE.Mesh(unitGeo, enemyMat);
            m.position.set((Math.random()-0.5)*8, 0.5, z);
            scene.add(m);
            enemies.push(m);
        }

        // --- INPUT ---
        const handleInput = (clientX) => {
            playerX = ((clientX / window.innerWidth) - 0.5) * 12;
            playerX = Math.max(-4.5, Math.min(4.5, playerX));
        };
        window.addEventListener('mousemove', e => handleInput(e.clientX));
        window.addEventListener('touchmove', e => handleInput(e.touches[0].clientX));

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            if (!gameActive || units.length === 0) return;

            const speed = 0.45;
            const leadZ = units[0].position.z;

            // Generate Content ahead
            if (leadZ < lastZ - 30) {
                lastZ = leadZ;
                createEnemy(leadZ - 60);
                if (Math.random() > 0.7) spawnGate(leadZ - 60);
            }

            // Move Units
            units.forEach((u, i) => {
                u.position.z -= speed;
                const offset = (i % 5 - 2) * 0.4;
                u.position.x += (playerX + offset - u.position.x) * 0.12;

                // Fire Bullets
                if (Math.random() > 0.96) {
                    const b = new THREE.Mesh(bulletGeo, bulletMat);
                    b.position.copy(u.position);
                    scene.add(b);
                    bullets.push(b);
                }
            });

            // Camera Follow (ZOOMED IN POSITION)
            // Lower Y (5) and closer Z (10) for that zoomed action look
            camera.position.set(0, 5, leadZ + 10);
            camera.lookAt(0, 1, leadZ - 5);
            pLight.position.set(playerX, 5, leadZ);

            // Bullet Physics & cleanup
            bullets.forEach((b, i) => {
                b.position.z -= 1.2;
                if (b.position.z < leadZ - 50) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
                enemies.forEach((en, ei) => {
                    if (b.position.distanceTo(en.position) < 0.8) {
                        scene.remove(en); enemies.splice(ei, 1);
                        scene.remove(b); bullets.splice(i, 1);
                        gold += 10;
                    }
                });
            });

            // UI
            document.getElementById('count').innerText = units.length;
            document.getElementById('gold').innerText = gold;

            renderer.render(scene, camera);
        }

        function spawnGate(z) {
            const g = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.2), new THREE.MeshStandardMaterial({color: 0x00ff88, transparent:true, opacity:0.5}));
            g.position.set(Math.random()>0.5?2.5:-2.5, 1.5, z);
            g.userData = { val: 5, active: true };
            scene.add(g);
            gates.push(g);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
