<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smol Architect Elite v4</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,300;0,400;0,500;1,400&family=Clash+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #06070d;
  --surface: #0d0f1a;
  --surface2: #131522;
  --surface3: #1a1d2e;
  --border: rgba(255,255,255,0.06);
  --border2: rgba(255,255,255,0.1);
  --accent: #00d4ff;
  --accent2: #7c6aff;
  --accent3: #ff6ab0;
  --accent4: #00ff88;
  --accent5: #ffaa00;
  --text: #dde4f0;
  --muted: #5a6080;
  --muted2: #7a84a8;
  --font-ui: 'IBM Plex Mono', monospace;
  --font-display: 'Clash Display', 'IBM Plex Mono', monospace;
  --radius: 12px;
}

html, body { height: 100%; background: var(--bg); color: var(--text); font-family: var(--font-ui); font-size: 13px; overflow: hidden; }

body::before {
  content: '';
  position: fixed; inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
  pointer-events: none; z-index: 0; opacity: 0.4;
}

.blob { position: fixed; border-radius: 50%; filter: blur(80px); pointer-events: none; z-index: 0; }
.blob-1 { width: 500px; height: 400px; top: -150px; left: -100px; background: radial-gradient(ellipse, rgba(0,212,255,0.06), transparent 70%); }
.blob-2 { width: 400px; height: 350px; bottom: -100px; right: -80px; background: radial-gradient(ellipse, rgba(124,106,255,0.08), transparent 70%); }

#app {
  position: relative; z-index: 1;
  display: flex; flex-direction: column;
  height: 100vh; max-width: 900px; margin: 0 auto; padding: 0 20px;
}

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 0 12px; border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.header-brand { display: flex; align-items: center; gap: 10px; }
.logo {
  width: 34px; height: 34px; border-radius: 9px;
  background: linear-gradient(135deg, #00d4ff22, #7c6aff22);
  border: 1px solid rgba(0,212,255,0.3);
  display: flex; align-items: center; justify-content: center; font-size: 15px;
  box-shadow: 0 0 16px rgba(0,212,255,0.15), inset 0 1px 0 rgba(255,255,255,0.08);
}
.brand-text-main { font-family: var(--font-display); font-weight: 600; font-size: 15px; color: #fff; letter-spacing: -0.2px; }
.brand-text-sub { font-size: 10px; color: var(--muted); letter-spacing: 0.8px; text-transform: uppercase; margin-top: 1px; }
.header-right { display: flex; align-items: center; gap: 10px; }

.status-badge {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 999px;
  border: 1px solid var(--border); background: var(--surface);
  font-size: 10px; color: var(--muted); letter-spacing: 0.3px; transition: all 0.3s;
}
.status-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--muted); transition: all 0.3s; }
.status-badge.ready { border-color: rgba(0,255,120,0.2); }
.status-badge.ready .status-dot { background: #00ff88; box-shadow: 0 0 6px #00ff88; }
.status-badge.loading { border-color: rgba(255,200,0,0.2); }
.status-badge.loading .status-dot { background: #ffc800; box-shadow: 0 0 6px #ffc800; animation: blink 0.8s infinite; }
.status-badge.error { border-color: rgba(255,80,80,0.2); }
.status-badge.error .status-dot { background: #ff5050; box-shadow: 0 0 6px #ff5050; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

.token-display {
  font-size: 10px; color: var(--muted); padding: 4px 10px;
  border: 1px solid var(--border); border-radius: 999px;
  background: var(--surface); display: none; transition: all 0.3s;
}
.token-display.warn   { color: #ffc800; border-color: rgba(255,200,0,0.25); }
.token-display.danger { color: #ff5050; border-color: rgba(255,80,80,0.25); }

.memory-badge {
  display: none; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 999px;
  border: 1px solid rgba(255,170,0,0.3); background: rgba(255,170,0,0.07);
  font-size: 10px; color: var(--accent5); cursor: pointer; transition: all 0.2s;
}
.memory-badge:hover { background: rgba(255,170,0,0.13); }
.memory-badge.active { display: flex; }
.memory-badge-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--accent5); box-shadow: 0 0 6px var(--accent5); }

#load-screen {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 20px;
}
.load-card {
  background: var(--surface); border: 1px solid var(--border2);
  border-radius: 20px; padding: 36px 44px; max-width: 460px; width: 100%;
}
.load-glyph  { font-size: 44px; margin-bottom: 14px; display: block; }
.load-title  { font-family: var(--font-display); font-size: 20px; font-weight: 600; color: #fff; margin-bottom: 6px; }
.load-desc   { color: var(--muted2); font-size: 12px; line-height: 1.8; margin-bottom: 24px; }
.load-desc code { color: var(--accent); background: rgba(0,212,255,0.08); padding: 1px 5px; border-radius: 4px; }
.load-btn {
  width: 100%; padding: 13px;
  background: linear-gradient(135deg, rgba(0,212,255,0.15), rgba(124,106,255,0.15));
  border: 1px solid rgba(0,212,255,0.3); border-radius: var(--radius);
  color: var(--accent); font-family: var(--font-ui); font-weight: 500; font-size: 13px;
  cursor: pointer; transition: all 0.2s;
}
.load-btn:hover    { background: linear-gradient(135deg, rgba(0,212,255,0.22), rgba(124,106,255,0.22)); border-color: rgba(0,212,255,0.5); color: #fff; }
.load-btn:disabled { opacity: 0.4; cursor: not-allowed; }

#progress-box { width: 100%; max-width: 460px; display: none; flex-direction: column; gap: 8px; }
.prog-row   { display: flex; justify-content: space-between; font-size: 10px; color: var(--muted); }
.prog-track { width: 100%; height: 3px; background: var(--surface3); border-radius: 99px; overflow: hidden; }
.prog-fill  { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); border-radius: 99px; width: 0%; transition: width 0.4s ease; }

#mode-bar {
  display: none; align-items: center; gap: 6px;
  padding: 10px 0 6px; flex-shrink: 0; flex-wrap: wrap;
}
.mode-label { font-size: 10px; color: var(--muted); letter-spacing: 0.5px; text-transform: uppercase; margin-right: 4px; }
.mode-btn {
  padding: 5px 12px; border-radius: 999px;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted2); font-family: var(--font-ui); font-size: 11px;
  cursor: pointer; transition: all 0.18s; display: flex; align-items: center; gap: 5px;
}
.mode-btn:hover { border-color: var(--border2); color: var(--text); background: var(--surface2); }
.mode-btn.active          { border-color: var(--accent);  color: var(--accent);  background: rgba(0,212,255,0.07); }
.mode-btn.active.math     { border-color: #ffc800; color: #ffc800; background: rgba(255,200,0,0.07); }
.mode-btn.active.code     { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.07); }
.mode-btn.active.creative { border-color: var(--accent3); color: var(--accent3); background: rgba(255,106,176,0.07); }
.mode-sep { width: 1px; height: 16px; background: var(--border); margin: 0 4px; }
.clear-btn {
  margin-left: auto; padding: 5px 10px; border-radius: 999px;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted); font-family: var(--font-ui); font-size: 10px; cursor: pointer; transition: all 0.18s;
}
.clear-btn:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }

#chat-area { display: none; flex-direction: column; flex: 1; overflow: hidden; }
#messages {
  flex: 1; overflow-y: auto; padding: 18px 0; display: flex; flex-direction: column; gap: 18px;
  scrollbar-width: thin; scrollbar-color: var(--border) transparent;
}
#messages::-webkit-scrollbar { width: 3px; }
#messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#empty-state {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 8px;
  color: var(--muted); text-align: center; padding: 40px;
}
.empty-glyph { font-size: 32px; opacity: 0.3; margin-bottom: 6px; }
.empty-title { font-family: var(--font-display); font-size: 14px; color: rgba(255,255,255,0.2); font-weight: 500; }
.empty-hint  { font-size: 11px; opacity: 0.4; }
.suggestion-chips { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; margin-top: 14px; }
.chip {
  padding: 5px 12px; border-radius: 999px;
  border: 1px solid var(--border); background: var(--surface);
  color: var(--muted2); font-family: var(--font-ui); font-size: 11px;
  cursor: pointer; transition: all 0.18s;
}
.chip:hover { border-color: var(--border2); color: var(--text); background: var(--surface2); }

.msg { display: flex; gap: 10px; align-items: flex-start; animation: slideIn 0.22s ease; }
@keyframes slideIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
.msg.user { flex-direction: row-reverse; }
.av {
  width: 28px; height: 28px; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; flex-shrink: 0; margin-top: 3px;
}
.msg.user .av { background: var(--surface3); border: 1px solid rgba(124,106,255,0.2); }
.msg.ai   .av {
  background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(124,106,255,0.2));
  border: 1px solid rgba(0,212,255,0.25); box-shadow: 0 0 10px rgba(0,212,255,0.1);
}
.msg-wrap { display: flex; flex-direction: column; max-width: 75%; }
.msg.user .msg-wrap { align-items: flex-end; }
.bubble {
  padding: 11px 14px; border-radius: 14px;
  line-height: 1.65; font-size: 13px; white-space: pre-wrap; word-break: break-word;
}
.msg.user .bubble { background: var(--surface3); border: 1px solid rgba(124,106,255,0.15); border-top-right-radius: 3px; }
.msg.ai   .bubble { background: var(--surface);  border: 1px solid var(--border);            border-top-left-radius:  3px; }
.msg-meta { display: flex; align-items: center; gap: 8px; font-size: 10px; color: var(--muted); margin-top: 4px; padding: 0 2px; }
.msg.user .msg-meta { flex-direction: row-reverse; }
.msg-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s; }
.msg:hover .msg-actions { opacity: 1; }
.action-btn {
  padding: 2px 7px; border-radius: 5px;
  border: 1px solid var(--border); background: var(--surface2);
  color: var(--muted); font-family: var(--font-ui); font-size: 10px; cursor: pointer; transition: all 0.15s;
}
.action-btn:hover        { border-color: var(--border2); color: var(--text); }
.action-btn.regen:hover  { border-color: rgba(0,212,255,0.3); color: var(--accent); }

.mode-tag {
  display: inline-block; font-size: 9px; padding: 1px 6px; border-radius: 4px;
  margin-bottom: 5px; letter-spacing: 0.4px; text-transform: uppercase;
}
.mode-tag.chat     { background: rgba(0,212,255,0.1);   color: rgba(0,212,255,0.6); }
.mode-tag.math     { background: rgba(255,200,0,0.1);   color: rgba(255,200,0,0.6); }
.mode-tag.code     { background: rgba(0,255,136,0.1);   color: rgba(0,255,136,0.6); }
.mode-tag.creative { background: rgba(255,106,176,0.1); color: rgba(255,106,176,0.6); }
.mode-tag.web      { background: rgba(0,255,136,0.12);  color: rgba(0,255,136,0.8); }
.mode-tag.memory   { background: rgba(255,170,0,0.12);  color: rgba(255,170,0,0.85); }
.mode-tag.cached   { background: rgba(124,106,255,0.12);color: rgba(180,160,255,0.9); }

.web-status {
  font-size: 10px; padding: 5px 9px; border-radius: 6px; margin-bottom: 6px;
  display: flex; align-items: center; gap: 6px;
}
.web-status.searching   { color: #ffc800; border: 1px solid rgba(255,200,0,0.2);  background: rgba(255,200,0,0.05);  animation: blink 0.9s infinite; }
.web-status.found       { color: var(--accent4); border: 1px solid rgba(0,255,136,0.2); background: rgba(0,255,136,0.05); }
.web-status.failed      { color: #ff8050; border: 1px solid rgba(255,80,50,0.2);  background: rgba(255,80,50,0.05); }
.web-status.memory-hit  { color: var(--accent5); border: 1px solid rgba(255,170,0,0.25); background: rgba(255,170,0,0.05); }
.web-status.memory-miss { color: var(--muted2);  border: 1px solid var(--border); background: transparent; }
.web-status.cache-hit   { color: rgba(180,160,255,0.9); border: 1px solid rgba(124,106,255,0.25); background: rgba(124,106,255,0.06); }
.web-status.saved       { color: var(--accent5); border: 1px solid rgba(255,170,0,0.2); background: rgba(255,170,0,0.04); animation: fadeInSaved 0.4s ease; }
@keyframes fadeInSaved  { from{opacity:0;transform:translateY(-3px)} to{opacity:1;transform:translateY(0)} }

.sources-row { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
.source-chip {
  font-size: 9px; padding: 2px 8px; border-radius: 4px;
  background: rgba(0,255,136,0.07); border: 1px solid rgba(0,255,136,0.15);
  color: rgba(0,255,136,0.7); text-decoration: none;
  transition: all 0.15s; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;
}
.source-chip:hover { background: rgba(0,255,136,0.14); color: var(--accent4); }
.memory-source-chip {
  font-size: 9px; padding: 2px 8px; border-radius: 4px;
  background: rgba(255,170,0,0.07); border: 1px solid rgba(255,170,0,0.2);
  color: rgba(255,170,0,0.75); max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;
}
.cached-source-chip {
  font-size: 9px; padding: 2px 8px; border-radius: 4px;
  background: rgba(124,106,255,0.08); border: 1px solid rgba(124,106,255,0.2);
  color: rgba(180,160,255,0.8); max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;
}

.typing { display: flex; gap: 4px; padding: 4px 0; }
.typing span { width: 5px; height: 5px; background: var(--accent); border-radius: 50%; animation: tdot 1.1s infinite; opacity: 0.6; }
.typing span:nth-child(2) { animation-delay: 0.18s; }
.typing span:nth-child(3) { animation-delay: 0.36s; }
@keyframes tdot { 0%,60%,100%{transform:translateY(0)} 30%{transform:translateY(-5px)} }

.stop-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: rgba(255,80,80,0.1); border: 1px solid rgba(255,80,80,0.3);
  color: #ff5050; cursor: pointer; display: none; align-items: center; justify-content: center;
  transition: all 0.18s; font-size: 13px;
}
.stop-btn:hover    { background: rgba(255,80,80,0.2); box-shadow: 0 0 10px rgba(255,80,80,0.2); }
.stop-btn.visible  { display: flex; }

#input-area { padding: 12px 0 18px; border-top: 1px solid var(--border); flex-shrink: 0; }
.input-shell {
  display: flex; gap: 8px; align-items: flex-end;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 14px; padding: 9px 9px 9px 14px; transition: border-color 0.2s, box-shadow 0.2s;
}
.input-shell:focus-within { border-color: rgba(0,212,255,0.3); box-shadow: 0 0 0 3px rgba(0,212,255,0.06); }
.input-shell.web-mode     { border-color: rgba(0,255,136,0.3); box-shadow: 0 0 0 3px rgba(0,255,136,0.05); }
.input-shell.generating   { border-color: rgba(255,80,80,0.25); box-shadow: 0 0 0 3px rgba(255,80,80,0.05); }

#user-input {
  flex: 1; background: transparent; border: none; outline: none;
  color: var(--text); font-family: var(--font-ui); font-size: 13px;
  line-height: 1.5; resize: none; max-height: 130px; min-height: 20px; scrollbar-width: none;
}
#user-input::placeholder { color: var(--muted); }

.icon-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: transparent; border: 1px solid var(--border);
  color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center;
  transition: all 0.18s; font-size: 15px; position: relative;
}
.icon-btn .tip {
  position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
  background: var(--surface2); border: 1px solid var(--border2);
  padding: 3px 8px; border-radius: 5px; font-size: 10px; color: var(--text);
  white-space: nowrap; pointer-events: none; opacity: 0; transition: opacity 0.15s; font-family: var(--font-ui);
}
.icon-btn:hover .tip { opacity: 1; }
.web-toggle:hover     { border-color: rgba(0,255,136,0.35); color: var(--accent4); background: rgba(0,255,136,0.06); }
.web-toggle.on        { border-color: rgba(0,255,136,0.45); color: var(--accent4); background: rgba(0,255,136,0.1); box-shadow: 0 0 12px rgba(0,255,136,0.15); }
.memory-toggle:hover  { border-color: rgba(255,170,0,0.4);  color: var(--accent5); background: rgba(255,170,0,0.07); }
.memory-toggle.has-docs { border-color: rgba(255,170,0,0.4); color: var(--accent5); background: rgba(255,170,0,0.1); box-shadow: 0 0 12px rgba(255,170,0,0.12); }

.send-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(124,106,255,0.2));
  border: 1px solid rgba(0,212,255,0.25); color: var(--accent); cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: all 0.18s;
}
.send-btn:hover    { background: linear-gradient(135deg, rgba(0,212,255,0.3), rgba(124,106,255,0.3)); color: #fff; box-shadow: 0 0 12px rgba(0,212,255,0.15); }
.send-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.send-btn svg { width: 14px; height: 14px; }

.input-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 6px; padding: 0 2px; }
.input-hint   { font-size: 10px; color: var(--muted); opacity: 0.5; }
.right-hints  { display: flex; align-items: center; gap: 10px; }
.web-on-label { font-size: 10px; color: var(--accent4); display: none; }
.web-on-label.show { display: block; }
.mem-on-label { font-size: 10px; color: var(--accent5); display: none; }
.mem-on-label.show { display: block; }
.temp-display { font-size: 10px; color: var(--muted); }
.temp-display span { color: var(--muted2); }
.gen-indicator { font-size: 10px; color: #ff5050; display: none; animation: blink 0.9s infinite; }
.gen-indicator.show { display: block; }

#memory-panel {
  display: none; position: fixed; top: 0; right: 0; bottom: 0;
  width: 340px; background: var(--surface); border-left: 1px solid var(--border2);
  z-index: 50; flex-direction: column; box-shadow: -8px 0 32px rgba(0,0,0,0.4);
  animation: slidePanel 0.22s ease;
}
#memory-panel.open { display: flex; }
@keyframes slidePanel { from{transform:translateX(100%)} to{transform:translateX(0)} }

.panel-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 18px; border-bottom: 1px solid var(--border);
}
.panel-title { font-family: var(--font-display); font-size: 14px; font-weight: 600; color: #fff; display: flex; align-items: center; gap: 8px; }
.panel-close {
  width: 28px; height: 28px; border-radius: 7px; border: 1px solid var(--border); background: transparent;
  color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 14px; transition: all 0.15s;
}
.panel-close:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }
.panel-body {
  flex: 1; overflow-y: auto; padding: 16px 18px; display: flex; flex-direction: column; gap: 14px;
  scrollbar-width: thin; scrollbar-color: var(--border) transparent;
}
.drop-zone {
  border: 2px dashed rgba(255,170,0,0.25); border-radius: 14px;
  padding: 28px 20px; text-align: center; cursor: pointer;
  transition: all 0.2s; background: rgba(255,170,0,0.03);
  display: flex; flex-direction: column; align-items: center; gap: 8px; user-select: none;
}
.drop-zone:hover, .drop-zone.drag-over { border-color: rgba(255,170,0,0.55); background: rgba(255,170,0,0.07); }
.drop-zone-icon  { font-size: 26px; pointer-events: none; }
.drop-zone-label { font-size: 12px; color: var(--muted2); line-height: 1.6; pointer-events: none; }
.drop-zone-label strong { color: var(--accent5); }
.drop-zone-sub   { font-size: 10px; color: var(--muted); pointer-events: none; }

#mem-progress { display: none; flex-direction: column; gap: 6px; }
.mem-prog-row   { display: flex; justify-content: space-between; font-size: 10px; color: var(--muted); }
.mem-prog-track { width: 100%; height: 3px; background: var(--surface3); border-radius: 99px; overflow: hidden; }
.mem-prog-fill  { height: 100%; background: linear-gradient(90deg, var(--accent5), #ff8800); border-radius: 99px; width: 0%; transition: width 0.3s; }

#mem-stats {
  display: none; padding: 10px 12px; border-radius: 10px;
  background: rgba(255,170,0,0.06); border: 1px solid rgba(255,170,0,0.15);
  font-size: 10px; color: var(--accent5);
}
.panel-section-title {
  font-size: 9px; letter-spacing: 0.6px; text-transform: uppercase;
  color: var(--muted); padding: 0 2px; margin-bottom: -6px;
}
.doc-list { display: flex; flex-direction: column; gap: 8px; }
.doc-item {
  display: flex; align-items: center; gap: 10px; padding: 10px 12px; border-radius: 10px;
  background: var(--surface2); border: 1px solid var(--border); transition: all 0.15s;
}
.doc-item:hover            { border-color: rgba(255,170,0,0.2); }
.doc-item.web-cached       { border-color: rgba(124,106,255,0.15); }
.doc-item.web-cached:hover { border-color: rgba(124,106,255,0.3); }
.doc-icon { font-size: 18px; flex-shrink: 0; }
.doc-info { flex: 1; min-width: 0; }
.doc-name { font-size: 11px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.doc-meta { font-size: 10px; color: var(--muted); margin-top: 2px; }
.doc-remove {
  width: 22px; height: 22px; border-radius: 5px; flex-shrink: 0;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 11px; transition: all 0.15s;
}
.doc-remove:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }
.panel-empty { text-align: center; color: var(--muted); font-size: 11px; padding: 20px 0; line-height: 1.8; }
.clear-mem-btn {
  width: 100%; padding: 9px; border-radius: 9px;
  border: 1px solid rgba(255,80,80,0.2); background: transparent;
  color: #ff6060; font-family: var(--font-ui); font-size: 11px; cursor: pointer; transition: all 0.18s;
}
.clear-mem-btn:hover { background: rgba(255,80,80,0.06); border-color: rgba(255,80,80,0.4); }

#toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(60px);
  background: var(--surface2); border: 1px solid var(--border2);
  border-radius: 9px; padding: 8px 16px; font-size: 12px; color: var(--text);
  transition: transform 0.3s ease; z-index: 200; white-space: nowrap;
}
#toast.show { transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>
<div class="blob blob-1"></div>
<div class="blob blob-2"></div>

<div id="app">
  <header>
    <div class="header-brand">
      <div class="logo">üß†</div>
      <div>
        <div class="brand-text-main">Smol Architect Elite</div>
        <div class="brand-text-sub">v4 ¬∑ 360M ¬∑ On-Device</div>
      </div>
    </div>
    <div class="header-right">
      <div class="token-display" id="token-display">0 / 2048 tokens</div>
      <div class="memory-badge" id="memory-badge" onclick="openMemoryPanel()">
        <div class="memory-badge-dot"></div>
        <span id="memory-badge-text">0 chunks</span>
      </div>
      <div class="status-badge" id="status-badge">
        <div class="status-dot"></div>
        <span id="status-text">Not loaded</span>
      </div>
    </div>
  </header>

  <div id="load-screen">
    <div class="load-card">
      <span class="load-glyph">‚ö°</span>
      <div class="load-title">Load Your Fine-Tuned Model</div>
      <div class="load-desc">
        Runs <code>100% on your device</code>. Downloads <code>Smol_Architect_Elite_v4.gguf</code> once (~300MB), cached forever in your browser. No server. No API key.
      </div>
      <button class="load-btn" id="load-btn" onclick="loadModel()">‚Üì Download & Run Model</button>
    </div>
    <div id="progress-box">
      <div class="prog-row">
        <span id="prog-label">Downloading...</span>
        <span id="prog-pct">0%</span>
      </div>
      <div class="prog-track"><div class="prog-fill" id="prog-fill"></div></div>
    </div>
  </div>

  <div id="mode-bar">
    <span class="mode-label">Mode</span>
    <button class="mode-btn active" id="mode-chat"     onclick="setMode('chat')">üí¨ Chat</button>
    <button class="mode-btn"        id="mode-math"     onclick="setMode('math')">üî¢ Math</button>
    <button class="mode-btn"        id="mode-code"     onclick="setMode('code')">üíª Code</button>
    <button class="mode-btn"        id="mode-creative" onclick="setMode('creative')">‚ú® Creative</button>
    <div class="mode-sep"></div>
    <button class="clear-btn" onclick="clearChat()">‚Ü∫ Reset</button>
  </div>

  <div id="chat-area">
    <div id="messages">
      <div id="empty-state">
        <div class="empty-glyph">üß†</div>
        <div class="empty-title">Ready ‚Äî pick a mode or start typing</div>
        <div class="empty-hint">üåê Web results auto-save to üìö memory for offline use</div>
        <div class="suggestion-chips" id="chips"></div>
      </div>
    </div>
    <div id="input-area">
      <div class="input-shell" id="input-shell">
        <textarea id="user-input" placeholder="Message Smol Architect..." rows="1"
          onkeydown="handleKey(event)" oninput="autoResize(this)"></textarea>
        <button class="icon-btn web-toggle" id="web-toggle" onclick="toggleWeb()">
          üåê<span class="tip">Web search: OFF</span>
        </button>
        <button class="icon-btn memory-toggle" id="memory-toggle-btn" onclick="openMemoryPanel()">
          üìö<span class="tip">Memory Base</span>
        </button>
        <button class="stop-btn" id="stop-btn" onclick="stopGeneration()" title="Stop generation">‚ñ†</button>
        <button class="send-btn" id="send-btn" onclick="sendMessage()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/>
          </svg>
        </button>
      </div>
      <div class="input-footer">
        <span class="input-hint">Enter to send ¬∑ Shift+Enter for newline</span>
        <div class="right-hints">
          <span class="gen-indicator" id="gen-indicator">‚óè generating</span>
          <span class="web-on-label" id="web-on-label">üåê web on</span>
          <span class="mem-on-label" id="mem-on-label">üìö memory on</span>
          <span class="temp-display">temp: <span id="temp-label">0.72</span></span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="memory-panel">
  <div class="panel-header">
    <div class="panel-title">üìö Memory Base</div>
    <button class="panel-close" id="panel-close-btn">‚úï</button>
  </div>
  <div class="panel-body">
    <div class="drop-zone" id="drop-zone">
      <div class="drop-zone-icon">üìÑ</div>
      <div class="drop-zone-label"><strong>Click to upload</strong> or drag & drop</div>
      <div class="drop-zone-sub">PDF & TXT ¬∑ Web results auto-save here too</div>
    </div>
    <input type="file" id="file-input" accept=".pdf,.txt" multiple style="display:none">
    <div id="mem-progress">
      <div class="mem-prog-row">
        <span id="mem-prog-label">Processing...</span>
        <span id="mem-prog-pct">0%</span>
      </div>
      <div class="mem-prog-track"><div class="mem-prog-fill" id="mem-prog-fill"></div></div>
    </div>
    <div id="mem-stats"></div>
    <div id="uploaded-section" style="display:none">
      <div class="panel-section-title">üìÑ Uploaded documents</div>
      <div class="doc-list" id="uploaded-list"></div>
    </div>
    <div id="webcache-section" style="display:none">
      <div class="panel-section-title">üåê Cached web results</div>
      <div class="doc-list" id="webcache-list"></div>
    </div>
    <div class="panel-empty" id="doc-empty">
      No documents loaded yet.<br>
      Upload a PDF/TXT or enable üåê web search ‚Äî<br>
      results will be saved here automatically.
    </div>
    <button class="clear-mem-btn" id="clear-mem-btn" style="display:none">‚úï Clear all memory</button>
  </div>
</div>

<div id="toast"></div>

<script type="module">
const WLLAMA_VER  = "2.3.0";
const WLLAMA_CDNS = [
  `https://esm.sh/@wllama/wllama@${WLLAMA_VER}`,
  `https://cdn.jsdelivr.net/npm/@wllama/wllama@${WLLAMA_VER}/dist`
];
const MODEL_URL     = "https://huggingface.co/Trapside/Trapside/resolve/main/Smol_Architect_Elite_v4.gguf";
const MAX_CTX       = 2048;
const HISTORY_TURNS = 10;
const CHUNK_SIZE    = 400;
const CHUNK_OVERLAP = 80;
const TOP_K_CHUNKS  = 4;
const MEM_CTX_LIMIT = 1400;

let wllama        = null;
let generating    = false;
let currentMode   = 'chat';
let webSearchOn   = false;
let history       = [];
let lastAiMsgEl   = null;
let shouldStop    = false;
let pdfJsReady    = false;
let uploadedDocs  = [];
let webCacheDocs  = [];
let memoryChunks  = [];

const MODES = {
  chat: {
    temp: 0.72, top_p: 0.9, top_k: 40,
    rep_pen: 1.35, pen_freq: 0.15, pen_present: 0.10,
    maxTokens: 450,
    system: `You are Smol Architect Elite, a helpful, honest, and friendly assistant.
You remember everything said earlier in the conversation and refer back to it naturally.
You answer clearly and concisely. You are warm and never make things up. If unsure, say so honestly.`,
    placeholder: "Ask me anything...",
    suggestions: ["What is machine learning?", "Tell me a fun space fact", "Explain black holes simply"]
  },
  math: {
    temp: 0.2, top_p: 0.8, top_k: 20,
    rep_pen: 1.30, pen_freq: 0.15, pen_present: 0.10,
    maxTokens: 500,
    system: `You are Smol Architect Elite in Math Mode. You are a precise step-by-step math solver.
ALWAYS show working clearly. Label each step (Step 1:, Step 2:, etc.) then state "Answer: X" at the end.
Never skip steps. State assumptions if a problem is ambiguous.`,
    placeholder: "Enter a math problem...",
    suggestions: ["48 cookies, sell 3/4, give 6 away. How many left?", "What is 15% of 240?", "Solve: 2x + 7 = 19"]
  },
  code: {
    temp: 0.25, top_p: 0.85, top_k: 30,
    rep_pen: 1.30, pen_freq: 0.15, pen_present: 0.10,
    maxTokens: 600,
    system: `You are Smol Architect Elite in Code Mode. You are a precise Python assistant.
Always use proper syntax, include comments, and descriptive names. Format code in triple backtick python blocks.
Explain what the code does and why. If debugging: root cause first, then fixed code, then explanation.`,
    placeholder: "Describe a coding problem or paste code to debug...",
    suggestions: ["Write a function to find duplicates in a list", "Explain list comprehensions", "Why does dividing by zero crash Python?"]
  },
  creative: {
    temp: 0.92, top_p: 0.95, top_k: 60,
    rep_pen: 1.40, pen_freq: 0.15, pen_present: 0.10,
    maxTokens: 500,
    system: `You are Smol Architect Elite in Creative Mode. You are an imaginative writing assistant.
Be vivid, original, and engaging. Avoid cliches. Surprise the reader.
Commit fully to the creative direction. Use concrete sensory details.`,
    placeholder: "Give me a creative writing prompt...",
    suggestions: ["Story opening: library after midnight", "Explain the internet as a medieval kingdom", "Poem about debugging code"]
  }
};

function loadPdfJs() {
  return new Promise((resolve, reject) => {
    if (pdfJsReady && typeof pdfjsLib !== 'undefined') { resolve(pdfjsLib); return; }
    const CDN    = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
    const WORKER = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const s = document.createElement('script');
    s.src = CDN;
    s.onload = () => {
      try { window.pdfjsLib.GlobalWorkerOptions.workerSrc = WORKER; pdfJsReady = true; resolve(window.pdfjsLib); }
      catch(e) { reject(new Error('PDF.js worker config failed: ' + e.message)); }
    };
    s.onerror = () => reject(new Error('Failed to load PDF.js ‚Äî check your internet connection.'));
    document.head.appendChild(s);
  });
}

function readAsText(file) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload  = e => res(e.target.result);
    r.onerror = () => rej(new Error('Could not read ' + file.name));
    r.readAsText(file, 'UTF-8');
  });
}
function readAsArrayBuffer(file) {
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload  = e => res(e.target.result);
    r.onerror = () => rej(new Error('Could not read ' + file.name));
    r.readAsArrayBuffer(file);
  });
}

async function parseTxt(file) {
  const text = await readAsText(file);
  if (!text || !text.trim()) throw new Error(file.name + ' is empty.');
  return text;
}

async function parsePdf(file) {
  setMemProgress(0, 'Loading PDF engine...');
  const lib = await loadPdfJs();
  setMemProgress(5, 'Reading PDF...');
  const buf = await readAsArrayBuffer(file);
  let pdf;
  try { pdf = await lib.getDocument({ data: buf }).promise; }
  catch(e) { throw new Error('Cannot parse PDF: ' + e.message); }
  let text = '';
  const total = pdf.numPages;
  for (let i = 1; i <= total; i++) {
    const page    = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += content.items.map(it => it.str).join(' ') + '\n\n';
    setMemProgress(5 + Math.round((i / total) * 90), `Page ${i} / ${total}...`);
  }
  if (!text.trim() || text.trim().length < 20)
    throw new Error(file.name + ' has no extractable text (may be a scanned image PDF).');
  return text;
}

function chunkText(text, docName, docType = 'file') {
  const clean  = text.replace(/\r\n/g,'\n').replace(/\n{3,}/g,'\n\n').trim();
  const chunks = [];
  let start = 0;
  while (start < clean.length) {
    const end   = Math.min(start + CHUNK_SIZE, clean.length);
    let   slice = clean.slice(start, end);
    if (end < clean.length) {
      const last = Math.max(
        slice.lastIndexOf('. '), slice.lastIndexOf('.\n'),
        slice.lastIndexOf('? '), slice.lastIndexOf('! ')
      );
      if (last > CHUNK_SIZE * 0.5) slice = clean.slice(start, start + last + 1);
    }
    const trimmed = slice.trim();
    if (trimmed.length > 20) chunks.push({ text: trimmed, docName, docType });
    const advance = slice.length - CHUNK_OVERLAP;
    start += advance > 0 ? advance : CHUNK_SIZE;
  }
  return chunks;
}

const STOP_WORDS = new Set([
  'a','an','the','is','it','in','on','at','to','of','and','or','but','for',
  'with','this','that','are','was','were','be','been','have','has','had',
  'do','does','did','will','would','could','should','may','might','not',
  'from','by','as','if','so','what','how','when','where','who','which',
  'i','you','he','she','we','they','me','him','her','us','them','my','your',
  'his','its','our','their','can','just','also','about','than','then',
  'there','here','all','one','more','some','any','no','up','out','get'
]);
function tokenize(text) {
  return text.toLowerCase().replace(/[^a-z0-9\s]/g,' ').split(/\s+/)
    .filter(w => w.length > 2 && !STOP_WORDS.has(w));
}
function buildIDF(chunks) {
  const df = {};
  for (const c of chunks) for (const t of new Set(tokenize(c.text))) df[t] = (df[t]||0)+1;
  const N = chunks.length || 1; const idf = {};
  for (const [t,f] of Object.entries(df)) idf[t] = Math.log((N+1)/(f+1))+1;
  return idf;
}
function retrieveChunks(query, topK = TOP_K_CHUNKS) {
  if (!memoryChunks.length) return [];
  const idf = buildIDF(memoryChunks); const qT = tokenize(query);
  if (!qT.length) return [];
  return memoryChunks
    .map(c => {
      const cT = tokenize(c.text); const cS = new Set(cT); let score = 0;
      for (const q of qT) if (cS.has(q)) score += (idf[q]||1);
      return { c, score: score / Math.sqrt(cT.length+1) };
    })
    .filter(s => s.score > 0)
    .sort((a,b) => b.score - a.score)
    .slice(0, topK)
    .map(s => s.c);
}

function openMemoryPanel()  { document.getElementById('memory-panel').classList.add('open'); }
function closeMemoryPanel() { document.getElementById('memory-panel').classList.remove('open'); }

document.getElementById('panel-close-btn').addEventListener('click', closeMemoryPanel);
document.getElementById('clear-mem-btn').addEventListener('click', clearMemory);

const dropZone  = document.getElementById('drop-zone');
const fileInput = document.getElementById('file-input');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover',  e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove('drag-over'); });
dropZone.addEventListener('drop', e => {
  e.preventDefault(); dropZone.classList.remove('drag-over');
  const files = Array.from(e.dataTransfer.files);
  if (files.length) processFiles(files);
});
fileInput.addEventListener('change', e => {
  const files = Array.from(e.target.files);
  if (files.length) processFiles(files);
  fileInput.value = '';
});

async function processFiles(files) {
  for (const file of files) {
    const ext = file.name.split('.').pop().toLowerCase();
    if (!['pdf','txt'].includes(ext)) { showToast('‚ö† Only PDF and TXT supported'); continue; }
    if (uploadedDocs.find(d => d.name === file.name)) { showToast('‚ö† "' + file.name + '" already loaded'); continue; }
    try {
      setMemProgress(0, 'Starting...');
      let raw = '';
      if (ext === 'txt') { setMemProgress(30,'Reading...'); raw = await parseTxt(file); setMemProgress(90,'Chunking...'); }
      else               { raw = await parsePdf(file); setMemProgress(95,'Chunking...'); }
      const chunks = chunkText(raw, file.name, ext);
      if (!chunks.length) throw new Error('No usable text extracted.');
      setMemProgress(100,'Done!'); setTimeout(hideMemProgress, 600);
      const id = Date.now() + Math.random();
      uploadedDocs.push({ id, name: file.name, type: ext, chunkCount: chunks.length, charCount: raw.length });
      memoryChunks.push(...chunks);
      renderDocList(); updateMemoryUI();
      showToast('üìö Loaded "' + file.name + '" ‚Äî ' + chunks.length + ' chunks');
    } catch(err) {
      console.error(err); hideMemProgress();
      showToast('‚ùå ' + (err.message || 'Failed to parse ' + file.name));
    }
  }
}

function removeDoc(id, bucket) {
  let doc;
  if (bucket === 'upload') { doc = uploadedDocs.find(d => d.id === id); if (doc) uploadedDocs = uploadedDocs.filter(d => d.id !== id); }
  else                     { doc = webCacheDocs.find(d => d.id === id);  if (doc) webCacheDocs  = webCacheDocs.filter(d => d.id !== id); }
  if (!doc) return;
  memoryChunks = memoryChunks.filter(c => c.docName !== doc.name);
  renderDocList(); updateMemoryUI();
  showToast('üóë Removed "' + doc.name + '"');
}

function clearMemory() {
  uploadedDocs = []; webCacheDocs = []; memoryChunks = [];
  renderDocList(); updateMemoryUI();
  showToast('Memory Base cleared');
}

function renderDocList() {
  const uploadedList  = document.getElementById('uploaded-list');
  const webcacheList  = document.getElementById('webcache-list');
  const uploadSection = document.getElementById('uploaded-section');
  const cacheSection  = document.getElementById('webcache-section');
  const emptyEl       = document.getElementById('doc-empty');
  const clearBtn      = document.getElementById('clear-mem-btn');
  uploadedList.innerHTML = '';
  webcacheList.innerHTML = '';
  const hasUploads = uploadedDocs.length > 0;
  const hasCache   = webCacheDocs.length > 0;
  const hasAny     = hasUploads || hasCache;
  uploadSection.style.cssText = hasUploads ? 'display:flex;flex-direction:column;gap:8px' : 'display:none';
  cacheSection.style.cssText  = hasCache   ? 'display:flex;flex-direction:column;gap:8px' : 'display:none';
  emptyEl.style.display  = hasAny ? 'none'  : 'block';
  clearBtn.style.display = hasAny ? 'block' : 'none';
  const buildItem = (doc, bucket) => {
    const el = document.createElement('div');
    el.className = 'doc-item' + (bucket === 'web' ? ' web-cached' : '');
    const icons = { pdf:'üìï', txt:'üìÑ', web:'üåê' };
    const kb    = (doc.charCount / 1024).toFixed(1);
    const meta  = doc.type === 'web'
      ? doc.chunkCount + ' chunks ¬∑ ' + kb + ' KB ¬∑ ' + new Date(doc.savedAt).toLocaleDateString()
      : doc.chunkCount + ' chunks ¬∑ ' + kb + ' KB';
    const iconEl = document.createElement('div'); iconEl.className = 'doc-icon'; iconEl.textContent = icons[doc.type]||'üìÑ';
    const info   = document.createElement('div'); info.className = 'doc-info';
    const nameEl = document.createElement('div'); nameEl.className = 'doc-name'; nameEl.textContent = doc.name;
    const metaEl = document.createElement('div'); metaEl.className = 'doc-meta'; metaEl.textContent = meta;
    info.appendChild(nameEl); info.appendChild(metaEl);
    const btn = document.createElement('button'); btn.className = 'doc-remove'; btn.title = 'Remove'; btn.textContent = '‚úï';
    btn.addEventListener('click', () => removeDoc(doc.id, bucket === 'web' ? 'web' : 'upload'));
    el.appendChild(iconEl); el.appendChild(info); el.appendChild(btn);
    return el;
  };
  for (const doc of uploadedDocs) uploadedList.appendChild(buildItem(doc, 'upload'));
  for (const doc of webCacheDocs)  webcacheList.appendChild(buildItem(doc, 'web'));
}

function updateMemoryUI() {
  const hasDoc = memoryChunks.length > 0;
  document.getElementById('memory-badge').classList.toggle('active', hasDoc);
  document.getElementById('memory-badge-text').textContent = memoryChunks.length + ' chunks';
  document.getElementById('memory-toggle-btn').classList.toggle('has-docs', hasDoc);
  document.getElementById('mem-on-label').classList.toggle('show', hasDoc);
  const stats = document.getElementById('mem-stats');
  if (hasDoc) {
    const totalKb = (memoryChunks.reduce((a,c) => a + c.text.length, 0) / 1024).toFixed(1);
    const parts = [];
    if (uploadedDocs.length) parts.push(uploadedDocs.length + ' file' + (uploadedDocs.length > 1 ? 's' : ''));
    if (webCacheDocs.length) parts.push(webCacheDocs.length + ' web cache' + (webCacheDocs.length > 1 ? 's' : ''));
    stats.style.display = 'block';
    stats.textContent = 'üìö ' + parts.join(' ¬∑ ') + ' ¬∑ ' + memoryChunks.length + ' chunks ¬∑ ' + totalKb + ' KB';
  } else { stats.style.display = 'none'; }
}
renderDocList();

function saveWebResultToMemory(result, queryTitle) {
  const docName = 'üåê ' + queryTitle;
  if (webCacheDocs.find(d => d.name === docName)) return false;
  const sourceLines = result.sources.map(s => s.title + ' ‚Äî ' + s.url).join('\n');
  const fullText = '=== ' + queryTitle + ' ===\n\n' + result.context + '\n\n--- Sources ---\n' + sourceLines;
  const chunks = chunkText(fullText, docName, 'web');
  if (!chunks.length) return false;
  const id = Date.now() + Math.random();
  webCacheDocs.push({ id, name: docName, type: 'web', chunkCount: chunks.length, charCount: fullText.length, url: result.sources[0]?.url || '', savedAt: Date.now() });
  memoryChunks.push(...chunks);
  renderDocList(); updateMemoryUI();
  return true;
}

function toggleWeb() {
  webSearchOn = !webSearchOn;
  const btn   = document.getElementById('web-toggle');
  const label = document.getElementById('web-on-label');
  const shell = document.getElementById('input-shell');
  const tip   = btn.querySelector('.tip');
  btn.classList.toggle('on', webSearchOn);
  shell.classList.toggle('web-mode', webSearchOn);
  label.classList.toggle('show', webSearchOn);
  tip.textContent = 'Web search: ' + (webSearchOn ? 'ON' : 'OFF');
  showToast(webSearchOn ? 'üåê Web search ON ‚Äî results auto-save to memory' : 'Web search OFF');
}

async function fetchWebContext(query) {
  try {
    const res = await fetch('https://en.wikipedia.org/w/api.php?' + new URLSearchParams({
      action:'query', list:'search', srsearch: query, srlimit:'3', format:'json', origin:'*'
    }));
    if (!res.ok) throw new Error('status ' + res.status);
    const data    = await res.json();
    const results = data?.query?.search;
    if (!results?.length) return null;
    const topTitle = results[0].title;
    const summRes  = await fetch('https://en.wikipedia.org/api/rest_v1/page/summary/' + encodeURIComponent(topTitle));
    if (!summRes.ok) throw new Error('summary ' + summRes.status);
    const summData = await summRes.json();
    const extract  = summData?.extract;
    if (!extract || extract.length < 30) return null;
    const extra = results.slice(1,3).map(r => r.snippet.replace(/<[^>]+>/g,'').trim()).filter(s => s.length > 20).join('\n\n');
    return {
      context: (extract + (extra ? '\n\nRelated:\n' + extra : '')).substring(0,1200),
      topTitle,
      sources: [
        { title: topTitle, url: 'https://en.wikipedia.org/wiki/' + encodeURIComponent(topTitle.replace(/ /g,'_')) },
        ...results.slice(1,3).map(r => ({ title: r.title, url: 'https://en.wikipedia.org/wiki/' + encodeURIComponent(r.title.replace(/ /g,'_')) }))
      ]
    };
  } catch(err) { console.error('Web search error:', err); return null; }
}

function renderSuggestions() {
  const chips = document.getElementById('chips');
  if (!chips) return;
  chips.innerHTML = '';
  MODES[currentMode].suggestions.forEach(s => {
    const c = document.createElement('button'); c.className = 'chip'; c.textContent = s;
    c.addEventListener('click', () => { document.getElementById('user-input').value = s; sendMessage(); });
    chips.appendChild(c);
  });
}
renderSuggestions();

function setMode(mode) {
  currentMode = mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active','math','code','creative'));
  const btn = document.getElementById('mode-' + mode);
  btn.classList.add('active'); if (mode !== 'chat') btn.classList.add(mode);
  document.getElementById('user-input').placeholder = MODES[mode].placeholder;
  document.getElementById('temp-label').textContent  = MODES[mode].temp;
  renderSuggestions();
  showToast('Mode: ' + mode.charAt(0).toUpperCase() + mode.slice(1) + ' ‚Äî temp ' + MODES[mode].temp);
}

async function loadModel() {
  const btn = document.getElementById('load-btn');
  const box = document.getElementById('progress-box');
  const badge = document.getElementById('status-badge');
  const statusText = document.getElementById('status-text');
  btn.disabled = true; btn.textContent = 'Initializing...';
  box.style.display = 'flex';
  badge.className = 'status-badge loading'; statusText.textContent = 'Loading...';
  let Wllama = null;
  for (const base of WLLAMA_CDNS) {
    try { const mod = await import(base + '/src/index.js'); Wllama = mod.Wllama; if (Wllama) break; }
    catch(e) { console.warn('CDN failed:', base, e); }
  }
  if (!Wllama) {
    badge.className = 'status-badge error'; statusText.textContent = 'Error';
    btn.disabled = false; btn.textContent = '‚Ü∫ Retry';
    showToast('Could not load wllama ‚Äî check your connection'); return;
  }
  try {
    const base = WLLAMA_CDNS[0];
    wllama = new Wllama({
      'single-thread/wllama.js':        base + '/src/single-thread/wllama.js',
      'single-thread/wllama.wasm':      base + '/src/single-thread/wllama.wasm',
      'multi-thread/wllama.js':         base + '/src/multi-thread/wllama.js',
      'multi-thread/wllama.wasm':       base + '/src/multi-thread/wllama.wasm',
      'multi-thread/wllama.worker.mjs': base + '/src/multi-thread/wllama.worker.mjs',
    });
    statusText.textContent = 'Downloading...';
    await wllama.loadModelFromUrl(MODEL_URL, {
      progressCallback: ({ loaded, total }) => {
        const pct = total > 0 ? Math.round((loaded/total)*100) : 0;
        document.getElementById('prog-fill').style.width = pct + '%';
        document.getElementById('prog-pct').textContent  = pct + '%';
        document.getElementById('prog-label').textContent =
          'Downloading... ' + (loaded/1048576).toFixed(0) + ' / ' + (total/1048576).toFixed(0) + ' MB';
      },
      n_ctx: MAX_CTX, n_threads: navigator.hardwareConcurrency || 4,
    });
    document.getElementById('load-screen').style.display   = 'none';
    document.getElementById('mode-bar').style.display      = 'flex';
    document.getElementById('chat-area').style.display     = 'flex';
    document.getElementById('token-display').style.display = 'block';
    badge.className = 'status-badge ready'; statusText.textContent = 'Ready';
    document.getElementById('user-input').focus();
    updateTokenDisplay();
  } catch(err) {
    console.error(err);
    badge.className = 'status-badge error'; statusText.textContent = 'Error';
    btn.disabled = false; btn.textContent = '‚Ü∫ Retry';
    showToast('Failed to load model ‚Äî check console');
  }
}

function estimateTokens(t) { return Math.ceil(t.length / 3.8); }
function getHistoryTokens() { return history.reduce((n,m) => n + estimateTokens(m.content), 0); }
function updateTokenDisplay() {
  const el = document.getElementById('token-display');
  const used = getHistoryTokens(); const pct = used / MAX_CTX;
  el.textContent = used + ' / ' + MAX_CTX + ' tokens';
  el.className = 'token-display' + (pct > 0.85 ? ' danger' : pct > 0.65 ? ' warn' : '');
}

const SPECIAL_TOKEN_RE = /<\|im_(start|end)\|>/g;
function sanitize(text) { return text.replace(SPECIAL_TOKEN_RE,'').replace(/\u0000/g,''); }

function buildPrompt(userText, webContext, memContext) {
  const cfg = MODES[currentMode];
  let p = '<|im_start|>system\n' + cfg.system + '<|im_end|>\n';
  for (const m of history.slice(-(HISTORY_TURNS*2)))
    p += '<|im_start|>' + m.role + '\n' + m.content + '<|im_end|>\n';
  if (memContext)
    p += '<|im_start|>user\n[MEMORY BASE ‚Äî primary source from documents/cached web. Lead with this, refine with own knowledge if needed.]\n' +
         memContext + '<|im_end|>\n<|im_start|>assistant\nUnderstood, I have the document context.<|im_end|>\n';
  if (webContext)
    p += '<|im_start|>user\n[LIVE WEB CONTEXT ‚Äî fresh Wikipedia info.]\n' +
         webContext + '<|im_end|>\n<|im_start|>assistant\nUnderstood, I have the web context.<|im_end|>\n';
  p += '<|im_start|>user\n' + userText + '<|im_end|>\n<|im_start|>assistant\n';
  return p;
}

async function sendMessage() {
  if (generating || !wllama) return;
  const input = document.getElementById('user-input');
  const raw   = input.value.trim(); if (!raw) return;
  input.value = ''; input.style.height = 'auto';
  const es = document.getElementById('empty-state'); if (es) es.remove();
  const safe = sanitize(raw);
  addMessage('user', raw);
  history.push({ role:'user', content: safe });
  updateTokenDisplay();
  await generate(safe);
}

function stopGeneration() { if (!generating) return; shouldStop = true; showToast('‚èπ Generation stopped'); }

function setGeneratingUI(on) {
  const sendBtn = document.getElementById('send-btn');
  const stopBtn = document.getElementById('stop-btn');
  sendBtn.style.display = on ? 'none' : 'flex'; sendBtn.disabled = on;
  stopBtn.classList.toggle('visible', on);
  document.getElementById('gen-indicator').classList.toggle('show', on);
  document.getElementById('input-shell').classList.toggle('generating', on);
}

async function generate(sanitizedText) {
  generating = true; shouldStop = false;
  setGeneratingUI(true);
  const cfg    = MODES[currentMode];
  const aiEl   = addMessage('ai', null, true);
  lastAiMsgEl  = aiEl;
  const bubble = aiEl.querySelector('.bubble');
  bubble.innerHTML = '';
  const hasMemory = memoryChunks.length > 0;

  let memContext    = null;
  let matchedChunks = [];
  if (hasMemory) {
    matchedChunks = retrieveChunks(sanitizedText, TOP_K_CHUNKS);
    if (matchedChunks.length > 0) {
      let ctx = '';
      for (const c of matchedChunks) {
        const s = '[From: ' + c.docName + ']\n' + c.text + '\n\n';
        if (ctx.length + s.length > MEM_CTX_LIMIT) break;
        ctx += s;
      }
      memContext = ctx.trim();
    }
  }

  let webResult  = null;
  let usedCached = false;

  if (webSearchOn) {
    const webBar = document.createElement('div');
    webBar.className = 'web-status searching';
    webBar.textContent = 'üîç Searching Wikipedia...';
    bubble.appendChild(webBar); scrollBottom();
    webResult = await fetchWebContext(sanitizedText);
    if (webResult && webResult.context) {
      const saved = saveWebResultToMemory(webResult, webResult.topTitle);
      webBar.className = 'web-status found';
      webBar.textContent = '‚úì Wikipedia found' + (saved ? ' ¬∑ üíæ saved to memory' : ' ¬∑ already cached');
      const row = document.createElement('div'); row.className = 'sources-row';
      webResult.sources.forEach(s => {
        const a = document.createElement('a'); a.className = 'source-chip';
        a.href = s.url; a.target = '_blank'; a.rel = 'noopener noreferrer';
        a.textContent = '‚Üó ' + s.title; row.appendChild(a);
      });
      bubble.appendChild(row);
    } else {
      const cached = matchedChunks.filter(c => c.docType === 'web');
      if (cached.length > 0) {
        usedCached = true;
        webBar.className = 'web-status cache-hit';
        webBar.textContent = '‚ö° Offline ‚Äî serving from memory cache';
        const cachedDocs = [...new Set(cached.map(c => c.docName))];
        const row = document.createElement('div'); row.className = 'sources-row';
        cachedDocs.forEach(name => {
          const chip = document.createElement('span'); chip.className = 'cached-source-chip';
          chip.textContent = name; row.appendChild(chip);
        });
        bubble.appendChild(row);
      } else {
        webBar.className = 'web-status failed';
        webBar.textContent = '‚ö† No web access & no cache ‚Äî using model knowledge';
      }
    }
  } else if (memContext) {
    const isFromWeb = matchedChunks.some(c => c.docType === 'web');
    const tag = document.createElement('div');
    tag.className = 'mode-tag ' + (isFromWeb ? 'cached' : 'memory');
    tag.textContent = isFromWeb ? 'üìö cached web' : 'üìö memory';
    bubble.appendChild(tag);
    const memBar = document.createElement('div');
    memBar.className = 'web-status memory-hit';
    memBar.textContent = '‚úì Found ' + matchedChunks.length + ' relevant passage' + (matchedChunks.length > 1 ? 's' : '');
    bubble.appendChild(memBar);
    const matchedDocs = [...new Set(matchedChunks.map(c => c.docName))];
    const row = document.createElement('div'); row.className = 'sources-row';
    matchedDocs.forEach(name => {
      const chip = document.createElement('span');
      chip.className = name.startsWith('üåê') ? 'cached-source-chip' : 'memory-source-chip';
      chip.textContent = name; row.appendChild(chip);
    });
    bubble.appendChild(row);
  } else {
    const tag = document.createElement('div');
    tag.className = 'mode-tag ' + currentMode; tag.textContent = currentMode;
    bubble.appendChild(tag);
    if (hasMemory) {
      const miss = document.createElement('div');
      miss.className = 'web-status memory-miss';
      miss.textContent = '‚óã Nothing relevant in memory ‚Äî using model knowledge';
      bubble.appendChild(miss);
    }
  }

  if (webSearchOn) {
    const tag = document.createElement('div');
    tag.className = 'mode-tag ' + (usedCached ? 'cached' : 'web');
    tag.textContent = usedCached ? 'üìö cached' : 'üåê web';
    bubble.prepend(tag);
  }

  const textNode = document.createElement('span');
  bubble.appendChild(textNode);
  const dots = document.createElement('div');
  dots.className = 'typing'; dots.innerHTML = '<span></span><span></span><span></span>';
  bubble.appendChild(dots);

  try {
    const prompt = buildPrompt(sanitizedText, webResult?.context || null, memContext);
    let fullText = '';
    await wllama.createCompletion(prompt, {
      nPredict: cfg.maxTokens,
      sampling: {
        temp:            cfg.temp,
        top_p:           cfg.top_p,
        top_k:           cfg.top_k,
        penalty_repeat:  cfg.rep_pen,
        penalty_freq:    cfg.pen_freq,
        penalty_present: cfg.pen_present,
      },
      onNewToken: (_t, _p, cur) => {
        fullText = cur;
        if (dots.parentNode) dots.remove();
        textNode.textContent = cur; scrollBottom();
        if (shouldStop) return false;
      },
    });
    const final = fullText.trim() || '(no response ‚Äî try rephrasing)';
    textNode.textContent = final;
    history.push({ role:'assistant', content: shouldStop ? final + ' [stopped]' : final });
    updateTokenDisplay();
  } catch(err) {
    if (!shouldStop) {
      console.error(err);
      textNode.textContent = 'Generation error ‚Äî check console.';
      showToast('Error during generation');
    }
  } finally {
    generating = false; shouldStop = false; setGeneratingUI(false);
    if (dots.parentNode) dots.remove();
    document.getElementById('user-input').focus(); scrollBottom();
  }
}

async function regenLast() {
  if (generating || !wllama) return;
  if (history.length > 0 && history[history.length-1].role === 'assistant') history.pop();
  const userMsg = history.length > 0 && history[history.length-1].role === 'user'
    ? history[history.length-1].content : '';
  if (lastAiMsgEl?.parentNode) lastAiMsgEl.remove();
  else { const all = document.getElementById('messages').querySelectorAll('.msg.ai'); if (all.length) all[all.length-1].remove(); }
  lastAiMsgEl = null;
  if (userMsg) await generate(userMsg);
}

function copyMsg(btn) {
  const span = btn.closest('.msg').querySelector('.bubble span');
  if (!span) return;
  navigator.clipboard.writeText(span.textContent);
  btn.textContent = 'copied!'; setTimeout(() => { btn.textContent = 'copy'; }, 1200);
}

function clearChat() {
  history = []; lastAiMsgEl = null;
  document.getElementById('messages').innerHTML = `
    <div id="empty-state">
      <div class="empty-glyph">üß†</div>
      <div class="empty-title">Conversation cleared ‚Äî start fresh</div>
      <div class="empty-hint">üåê Web results auto-save to üìö memory for offline use</div>
      <div class="suggestion-chips" id="chips"></div>
    </div>`;
  renderSuggestions(); updateTokenDisplay();
}

function setMemProgress(pct, label) {
  document.getElementById('mem-progress').style.display = 'flex';
  document.getElementById('mem-prog-fill').style.width  = pct + '%';
  document.getElementById('mem-prog-pct').textContent   = pct + '%';
  document.getElementById('mem-prog-label').textContent = label;
}
function hideMemProgress() { document.getElementById('mem-progress').style.display = 'none'; }

function addMessage(role, text, typing) {
  const msgs = document.getElementById('messages');
  const el   = document.createElement('div'); el.className = 'msg ' + role;
  const now  = new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
  if (typing) {
    el.innerHTML =
      '<div class="av">üß†</div>' +
      '<div class="msg-wrap"><div class="bubble"></div>' +
      '<div class="msg-meta"><span>' + now + '</span>' +
      '<div class="msg-actions">' +
        '<button class="action-btn regen" onclick="regenLast()">‚Ü∫ regen</button>' +
        '<button class="action-btn" onclick="copyMsg(this)">copy</button>' +
      '</div></div></div>';
  } else {
    el.innerHTML =
      '<div class="av">' + (role==='user'?'üë§':'üß†') + '</div>' +
      '<div class="msg-wrap"><div class="bubble"></div>' +
      '<div class="msg-meta"><span>' + now + '</span></div></div>';
    el.querySelector('.bubble').textContent = text;
  }
  msgs.appendChild(el); scrollBottom(); return el;
}

function scrollBottom() { const m = document.getElementById('messages'); m.scrollTop = m.scrollHeight; }
function handleKey(e)   { if (e.key==='Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } }
function autoResize(el) { el.style.height='auto'; el.style.height=Math.min(el.scrollHeight,130)+'px'; }
function showToast(msg, dur=2800) {
  const t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), dur);
}

window.loadModel       = loadModel;
window.sendMessage     = sendMessage;
window.handleKey       = handleKey;
window.autoResize      = autoResize;
window.setMode         = setMode;
window.clearChat       = clearChat;
window.regenLast       = regenLast;
window.copyMsg         = copyMsg;
window.toggleWeb       = toggleWeb;
window.stopGeneration  = stopGeneration;
window.openMemoryPanel = openMemoryPanel;
</script>
</body>
</html>
