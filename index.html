<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smol Architect Elite v4</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,300;0,400;0,500;1,400&family=Clash+Display:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #06070d;
  --surface: #0d0f1a;
  --surface2: #131522;
  --surface3: #1a1d2e;
  --border: rgba(255,255,255,0.06);
  --border2: rgba(255,255,255,0.1);
  --accent: #00d4ff;
  --accent2: #7c6aff;
  --accent3: #ff6ab0;
  --accent4: #00ff88;
  --accent5: #ffaa00;
  --text: #dde4f0;
  --muted: #5a6080;
  --muted2: #7a84a8;
  --font-ui: 'IBM Plex Mono', monospace;
  --font-display: 'Clash Display', 'IBM Plex Mono', monospace;
  --radius: 12px;
}

html, body { height: 100%; background: var(--bg); color: var(--text); font-family: var(--font-ui); font-size: 13px; overflow: hidden; }

body::before {
  content: '';
  position: fixed; inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.04'/%3E%3C/svg%3E");
  pointer-events: none; z-index: 0; opacity: 0.4;
}

.blob { position: fixed; border-radius: 50%; filter: blur(80px); pointer-events: none; z-index: 0; }
.blob-1 { width: 500px; height: 400px; top: -150px; left: -100px; background: radial-gradient(ellipse, rgba(0,212,255,0.06), transparent 70%); }
.blob-2 { width: 400px; height: 350px; bottom: -100px; right: -80px; background: radial-gradient(ellipse, rgba(124,106,255,0.08), transparent 70%); }

#app {
  position: relative; z-index: 1;
  display: flex; flex-direction: column;
  height: 100vh; max-width: 900px; margin: 0 auto; padding: 0 20px;
}

header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 0 12px; border-bottom: 1px solid var(--border); flex-shrink: 0;
}
.header-brand { display: flex; align-items: center; gap: 10px; }
.logo {
  width: 34px; height: 34px; border-radius: 9px;
  background: linear-gradient(135deg, #00d4ff22, #7c6aff22);
  border: 1px solid rgba(0,212,255,0.3);
  display: flex; align-items: center; justify-content: center; font-size: 15px;
  box-shadow: 0 0 16px rgba(0,212,255,0.15), inset 0 1px 0 rgba(255,255,255,0.08);
}
.brand-text-main { font-family: var(--font-display); font-weight: 600; font-size: 15px; color: #fff; letter-spacing: -0.2px; }
.brand-text-sub { font-size: 10px; color: var(--muted); letter-spacing: 0.8px; text-transform: uppercase; margin-top: 1px; }
.header-right { display: flex; align-items: center; gap: 10px; }

.status-badge {
  display: flex; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 999px;
  border: 1px solid var(--border); background: var(--surface);
  font-size: 10px; color: var(--muted); letter-spacing: 0.3px; transition: all 0.3s;
}
.status-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--muted); transition: all 0.3s; }
.status-badge.ready { border-color: rgba(0,255,120,0.2); }
.status-badge.ready .status-dot { background: #00ff88; box-shadow: 0 0 6px #00ff88; }
.status-badge.loading { border-color: rgba(255,200,0,0.2); }
.status-badge.loading .status-dot { background: #ffc800; box-shadow: 0 0 6px #ffc800; animation: blink 0.8s infinite; }
.status-badge.error { border-color: rgba(255,80,80,0.2); }
.status-badge.error .status-dot { background: #ff5050; box-shadow: 0 0 6px #ff5050; }
@keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }

.token-display {
  font-size: 10px; color: var(--muted); padding: 4px 10px;
  border: 1px solid var(--border); border-radius: 999px;
  background: var(--surface); display: none; transition: all 0.3s;
}
.token-display.warn { color: #ffc800; border-color: rgba(255,200,0,0.25); }
.token-display.danger { color: #ff5050; border-color: rgba(255,80,80,0.25); }

/* â”€â”€ MEMORY BADGE in header â”€â”€ */
.memory-badge {
  display: none; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 999px;
  border: 1px solid rgba(255,170,0,0.3);
  background: rgba(255,170,0,0.07);
  font-size: 10px; color: var(--accent5);
  cursor: pointer; transition: all 0.2s;
}
.memory-badge:hover { background: rgba(255,170,0,0.13); }
.memory-badge.active { display: flex; }
.memory-badge-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--accent5); box-shadow: 0 0 6px var(--accent5); }

#load-screen {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 20px;
}
.load-card {
  background: var(--surface); border: 1px solid var(--border2);
  border-radius: 20px; padding: 36px 44px; max-width: 460px; width: 100%;
}
.load-glyph { font-size: 44px; margin-bottom: 14px; display: block; }
.load-title { font-family: var(--font-display); font-size: 20px; font-weight: 600; color: #fff; margin-bottom: 6px; }
.load-desc { color: var(--muted2); font-size: 12px; line-height: 1.8; margin-bottom: 24px; }
.load-desc code { color: var(--accent); background: rgba(0,212,255,0.08); padding: 1px 5px; border-radius: 4px; }
.load-btn {
  width: 100%; padding: 13px;
  background: linear-gradient(135deg, rgba(0,212,255,0.15), rgba(124,106,255,0.15));
  border: 1px solid rgba(0,212,255,0.3); border-radius: var(--radius);
  color: var(--accent); font-family: var(--font-ui); font-weight: 500; font-size: 13px;
  cursor: pointer; transition: all 0.2s;
}
.load-btn:hover { background: linear-gradient(135deg, rgba(0,212,255,0.22), rgba(124,106,255,0.22)); border-color: rgba(0,212,255,0.5); color: #fff; }
.load-btn:disabled { opacity: 0.4; cursor: not-allowed; }

#progress-box { width: 100%; max-width: 460px; display: none; flex-direction: column; gap: 8px; }
.prog-row { display: flex; justify-content: space-between; font-size: 10px; color: var(--muted); }
.prog-track { width: 100%; height: 3px; background: var(--surface3); border-radius: 99px; overflow: hidden; }
.prog-fill { height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); border-radius: 99px; width: 0%; transition: width 0.4s ease; }

#mode-bar {
  display: none; align-items: center; gap: 6px;
  padding: 10px 0 6px; flex-shrink: 0; flex-wrap: wrap;
}
.mode-label { font-size: 10px; color: var(--muted); letter-spacing: 0.5px; text-transform: uppercase; margin-right: 4px; }
.mode-btn {
  padding: 5px 12px; border-radius: 999px;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted2); font-family: var(--font-ui); font-size: 11px;
  cursor: pointer; transition: all 0.18s;
  display: flex; align-items: center; gap: 5px;
}
.mode-btn:hover { border-color: var(--border2); color: var(--text); background: var(--surface2); }
.mode-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0,212,255,0.07); }
.mode-btn.active.math { border-color: #ffc800; color: #ffc800; background: rgba(255,200,0,0.07); }
.mode-btn.active.code { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.07); }
.mode-btn.active.creative { border-color: var(--accent3); color: var(--accent3); background: rgba(255,106,176,0.07); }

.mode-sep { width: 1px; height: 16px; background: var(--border); margin: 0 4px; }
.clear-btn {
  margin-left: auto; padding: 5px 10px; border-radius: 999px;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted); font-family: var(--font-ui); font-size: 10px;
  cursor: pointer; transition: all 0.18s;
}
.clear-btn:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }

#chat-area { display: none; flex-direction: column; flex: 1; overflow: hidden; }
#messages {
  flex: 1; overflow-y: auto; padding: 18px 0; display: flex; flex-direction: column; gap: 18px;
  scrollbar-width: thin; scrollbar-color: var(--border) transparent;
}
#messages::-webkit-scrollbar { width: 3px; }
#messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

#empty-state {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 8px;
  color: var(--muted); text-align: center; padding: 40px;
}
.empty-glyph { font-size: 32px; opacity: 0.3; margin-bottom: 6px; }
.empty-title { font-family: var(--font-display); font-size: 14px; color: rgba(255,255,255,0.2); font-weight: 500; }
.empty-hint { font-size: 11px; opacity: 0.4; }
.suggestion-chips { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; margin-top: 14px; }
.chip {
  padding: 5px 12px; border-radius: 999px;
  border: 1px solid var(--border); background: var(--surface);
  color: var(--muted2); font-family: var(--font-ui); font-size: 11px;
  cursor: pointer; transition: all 0.18s;
}
.chip:hover { border-color: var(--border2); color: var(--text); background: var(--surface2); }

.msg { display: flex; gap: 10px; align-items: flex-start; animation: slideIn 0.22s ease; }
@keyframes slideIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
.msg.user { flex-direction: row-reverse; }
.av {
  width: 28px; height: 28px; border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; flex-shrink: 0; margin-top: 3px;
}
.msg.user .av { background: var(--surface3); border: 1px solid rgba(124,106,255,0.2); }
.msg.ai .av {
  background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(124,106,255,0.2));
  border: 1px solid rgba(0,212,255,0.25); box-shadow: 0 0 10px rgba(0,212,255,0.1);
}
.msg-wrap { display: flex; flex-direction: column; max-width: 75%; }
.msg.user .msg-wrap { align-items: flex-end; }
.bubble {
  padding: 11px 14px; border-radius: 14px;
  line-height: 1.65; font-size: 13px; white-space: pre-wrap; word-break: break-word;
}
.msg.user .bubble { background: var(--surface3); border: 1px solid rgba(124,106,255,0.15); border-top-right-radius: 3px; }
.msg.ai .bubble { background: var(--surface); border: 1px solid var(--border); border-top-left-radius: 3px; }
.msg-meta { display: flex; align-items: center; gap: 8px; font-size: 10px; color: var(--muted); margin-top: 4px; padding: 0 2px; }
.msg.user .msg-meta { flex-direction: row-reverse; }
.msg-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.15s; }
.msg:hover .msg-actions { opacity: 1; }
.action-btn {
  padding: 2px 7px; border-radius: 5px;
  border: 1px solid var(--border); background: var(--surface2);
  color: var(--muted); font-family: var(--font-ui); font-size: 10px;
  cursor: pointer; transition: all 0.15s;
}
.action-btn:hover { border-color: var(--border2); color: var(--text); }
.action-btn.regen:hover { border-color: rgba(0,212,255,0.3); color: var(--accent); }

.mode-tag {
  display: inline-block; font-size: 9px; padding: 1px 6px; border-radius: 4px;
  margin-bottom: 5px; letter-spacing: 0.4px; text-transform: uppercase;
}
.mode-tag.chat { background: rgba(0,212,255,0.1); color: rgba(0,212,255,0.6); }
.mode-tag.math { background: rgba(255,200,0,0.1); color: rgba(255,200,0,0.6); }
.mode-tag.code { background: rgba(0,255,136,0.1); color: rgba(0,255,136,0.6); }
.mode-tag.creative { background: rgba(255,106,176,0.1); color: rgba(255,106,176,0.6); }
.mode-tag.web { background: rgba(0,255,136,0.12); color: rgba(0,255,136,0.8); }
.mode-tag.memory { background: rgba(255,170,0,0.12); color: rgba(255,170,0,0.85); }

.web-status {
  font-size: 10px; padding: 5px 9px; border-radius: 6px; margin-bottom: 6px;
  display: flex; align-items: center; gap: 6px;
}
.web-status.searching { color: #ffc800; border: 1px solid rgba(255,200,0,0.2); background: rgba(255,200,0,0.05); animation: blink 0.9s infinite; }
.web-status.found { color: var(--accent4); border: 1px solid rgba(0,255,136,0.2); background: rgba(0,255,136,0.05); }
.web-status.failed { color: #ff8050; border: 1px solid rgba(255,80,50,0.2); background: rgba(255,80,50,0.05); }
.web-status.memory-hit { color: var(--accent5); border: 1px solid rgba(255,170,0,0.25); background: rgba(255,170,0,0.05); }
.web-status.memory-miss { color: var(--muted2); border: 1px solid var(--border); background: transparent; }

.sources-row { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 8px; }
.source-chip {
  font-size: 9px; padding: 2px 8px; border-radius: 4px;
  background: rgba(0,255,136,0.07); border: 1px solid rgba(0,255,136,0.15);
  color: rgba(0,255,136,0.7); text-decoration: none;
  transition: all 0.15s; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;
}
.source-chip:hover { background: rgba(0,255,136,0.14); color: var(--accent4); }
.memory-source-chip {
  font-size: 9px; padding: 2px 8px; border-radius: 4px;
  background: rgba(255,170,0,0.07); border: 1px solid rgba(255,170,0,0.2);
  color: rgba(255,170,0,0.75);
  max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: inline-block;
}

.typing { display: flex; gap: 4px; padding: 4px 0; }
.typing span { width: 5px; height: 5px; background: var(--accent); border-radius: 50%; animation: tdot 1.1s infinite; opacity: 0.6; }
.typing span:nth-child(2) { animation-delay: 0.18s; }
.typing span:nth-child(3) { animation-delay: 0.36s; }
@keyframes tdot { 0%,60%,100%{transform:translateY(0)} 30%{transform:translateY(-5px)} }

.stop-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: rgba(255,80,80,0.1); border: 1px solid rgba(255,80,80,0.3);
  color: #ff5050; cursor: pointer; display: none; align-items: center; justify-content: center;
  transition: all 0.18s; font-size: 13px;
}
.stop-btn:hover { background: rgba(255,80,80,0.2); box-shadow: 0 0 10px rgba(255,80,80,0.2); }
.stop-btn.visible { display: flex; }

#input-area { padding: 12px 0 18px; border-top: 1px solid var(--border); flex-shrink: 0; }
.input-shell {
  display: flex; gap: 8px; align-items: flex-end;
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 14px; padding: 9px 9px 9px 14px;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.input-shell:focus-within { border-color: rgba(0,212,255,0.3); box-shadow: 0 0 0 3px rgba(0,212,255,0.06); }
.input-shell.web-mode { border-color: rgba(0,255,136,0.3); box-shadow: 0 0 0 3px rgba(0,255,136,0.05); }
.input-shell.generating { border-color: rgba(255,80,80,0.25); box-shadow: 0 0 0 3px rgba(255,80,80,0.05); }

#user-input {
  flex: 1; background: transparent; border: none; outline: none;
  color: var(--text); font-family: var(--font-ui); font-size: 13px;
  line-height: 1.5; resize: none; max-height: 130px; min-height: 20px; scrollbar-width: none;
}
#user-input::placeholder { color: var(--muted); }

.icon-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: transparent; border: 1px solid var(--border);
  color: var(--muted); cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.18s; font-size: 15px; position: relative;
}
.icon-btn .tip {
  position: absolute; bottom: calc(100% + 8px); left: 50%; transform: translateX(-50%);
  background: var(--surface2); border: 1px solid var(--border2);
  padding: 3px 8px; border-radius: 5px; font-size: 10px; color: var(--text);
  white-space: nowrap; pointer-events: none; opacity: 0; transition: opacity 0.15s; font-family: var(--font-ui);
}
.icon-btn:hover .tip { opacity: 1; }

.web-toggle:hover { border-color: rgba(0,255,136,0.35); color: var(--accent4); background: rgba(0,255,136,0.06); }
.web-toggle.on { border-color: rgba(0,255,136,0.45); color: var(--accent4); background: rgba(0,255,136,0.1); box-shadow: 0 0 12px rgba(0,255,136,0.15); }

.memory-toggle:hover { border-color: rgba(255,170,0,0.4); color: var(--accent5); background: rgba(255,170,0,0.07); }
.memory-toggle.has-docs { border-color: rgba(255,170,0,0.4); color: var(--accent5); background: rgba(255,170,0,0.1); box-shadow: 0 0 12px rgba(255,170,0,0.12); }

.send-btn {
  width: 36px; height: 36px; border-radius: 9px; flex-shrink: 0;
  background: linear-gradient(135deg, rgba(0,212,255,0.2), rgba(124,106,255,0.2));
  border: 1px solid rgba(0,212,255,0.25); color: var(--accent); cursor: pointer;
  display: flex; align-items: center; justify-content: center; transition: all 0.18s;
}
.send-btn:hover { background: linear-gradient(135deg, rgba(0,212,255,0.3), rgba(124,106,255,0.3)); color: #fff; box-shadow: 0 0 12px rgba(0,212,255,0.15); }
.send-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.send-btn svg { width: 14px; height: 14px; }

.input-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 6px; padding: 0 2px; }
.input-hint { font-size: 10px; color: var(--muted); opacity: 0.5; }
.right-hints { display: flex; align-items: center; gap: 10px; }
.web-on-label { font-size: 10px; color: var(--accent4); display: none; }
.web-on-label.show { display: block; }
.mem-on-label { font-size: 10px; color: var(--accent5); display: none; }
.mem-on-label.show { display: block; }
.temp-display { font-size: 10px; color: var(--muted); }
.temp-display span { color: var(--muted2); }
.gen-indicator { font-size: 10px; color: #ff5050; display: none; animation: blink 0.9s infinite; }
.gen-indicator.show { display: block; }

/* â”€â”€ MEMORY PANEL â”€â”€ */
#memory-panel {
  display: none; position: fixed; top: 0; right: 0; bottom: 0;
  width: 340px; background: var(--surface); border-left: 1px solid var(--border2);
  z-index: 50; flex-direction: column;
  box-shadow: -8px 0 32px rgba(0,0,0,0.4);
  animation: slidePanel 0.22s ease;
}
#memory-panel.open { display: flex; }
@keyframes slidePanel { from{transform:translateX(100%)} to{transform:translateX(0)} }

.panel-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 18px; border-bottom: 1px solid var(--border);
}
.panel-title { font-family: var(--font-display); font-size: 14px; font-weight: 600; color: #fff; display: flex; align-items: center; gap: 8px; }
.panel-close {
  width: 28px; height: 28px; border-radius: 7px;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 14px; transition: all 0.15s;
}
.panel-close:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }

.panel-body { flex: 1; overflow-y: auto; padding: 16px 18px; display: flex; flex-direction: column; gap: 14px;
  scrollbar-width: thin; scrollbar-color: var(--border) transparent; }

/* Drop zone */
.drop-zone {
  border: 2px dashed rgba(255,170,0,0.25); border-radius: 14px;
  padding: 28px 20px; text-align: center; cursor: pointer;
  transition: all 0.2s; background: rgba(255,170,0,0.03);
  display: flex; flex-direction: column; align-items: center; gap: 8px;
}
.drop-zone:hover, .drop-zone.drag-over {
  border-color: rgba(255,170,0,0.55); background: rgba(255,170,0,0.07);
}
.drop-zone-icon { font-size: 26px; }
.drop-zone-label { font-size: 12px; color: var(--muted2); line-height: 1.6; }
.drop-zone-label strong { color: var(--accent5); }
.drop-zone-sub { font-size: 10px; color: var(--muted); }
#file-input { display: none; }

/* Processing bar */
#mem-progress { display: none; flex-direction: column; gap: 6px; }
.mem-prog-row { display: flex; justify-content: space-between; font-size: 10px; color: var(--muted); }
.mem-prog-track { width: 100%; height: 3px; background: var(--surface3); border-radius: 99px; overflow: hidden; }
.mem-prog-fill { height: 100%; background: linear-gradient(90deg, var(--accent5), #ff8800); border-radius: 99px; width: 0%; transition: width 0.3s; }

/* Stats bar */
#mem-stats {
  display: none; padding: 10px 12px; border-radius: 10px;
  background: rgba(255,170,0,0.06); border: 1px solid rgba(255,170,0,0.15);
  font-size: 10px; color: var(--accent5);
}

/* Doc list */
.doc-list { display: flex; flex-direction: column; gap: 8px; }
.doc-item {
  display: flex; align-items: center; gap: 10px;
  padding: 10px 12px; border-radius: 10px;
  background: var(--surface2); border: 1px solid var(--border);
  transition: all 0.15s;
}
.doc-item:hover { border-color: rgba(255,170,0,0.2); }
.doc-icon { font-size: 18px; flex-shrink: 0; }
.doc-info { flex: 1; min-width: 0; }
.doc-name { font-size: 11px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.doc-meta { font-size: 10px; color: var(--muted); margin-top: 2px; }
.doc-remove {
  width: 22px; height: 22px; border-radius: 5px; flex-shrink: 0;
  border: 1px solid var(--border); background: transparent;
  color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center;
  font-size: 11px; transition: all 0.15s;
}
.doc-remove:hover { border-color: rgba(255,80,80,0.3); color: #ff5050; background: rgba(255,80,80,0.05); }

.panel-empty { text-align: center; color: var(--muted); font-size: 11px; padding: 20px 0; line-height: 1.8; }

/* Clear all button */
.clear-mem-btn {
  width: 100%; padding: 9px; border-radius: 9px;
  border: 1px solid rgba(255,80,80,0.2); background: transparent;
  color: #ff6060; font-family: var(--font-ui); font-size: 11px;
  cursor: pointer; transition: all 0.18s;
}
.clear-mem-btn:hover { background: rgba(255,80,80,0.06); border-color: rgba(255,80,80,0.4); }

#toast {
  position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(60px);
  background: var(--surface2); border: 1px solid var(--border2);
  border-radius: 9px; padding: 8px 16px; font-size: 12px; color: var(--text);
  transition: transform 0.3s ease; z-index: 200; white-space: nowrap;
}
#toast.show { transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>
<div class="blob blob-1"></div>
<div class="blob blob-2"></div>

<div id="app">
  <header>
    <div class="header-brand">
      <div class="logo">ğŸ§ </div>
      <div>
        <div class="brand-text-main">Smol Architect Elite</div>
        <div class="brand-text-sub">v4 Â· 360M Â· On-Device</div>
      </div>
    </div>
    <div class="header-right">
      <div class="token-display" id="token-display">0 / 2048 tokens</div>
      <!-- Memory badge shows chunk count once docs loaded -->
      <div class="memory-badge" id="memory-badge" onclick="openMemoryPanel()">
        <div class="memory-badge-dot"></div>
        <span id="memory-badge-text">0 chunks</span>
      </div>
      <div class="status-badge" id="status-badge">
        <div class="status-dot"></div>
        <span id="status-text">Not loaded</span>
      </div>
    </div>
  </header>

  <div id="load-screen">
    <div class="load-card">
      <span class="load-glyph">âš¡</span>
      <div class="load-title">Load Your Fine-Tuned Model</div>
      <div class="load-desc">
        Runs <code>100% on your device</code>. Downloads <code>Smol_Architect_Elite_v4.gguf</code> once (~300MB), cached forever in your browser. No server. No API key.
      </div>
      <button class="load-btn" id="load-btn" onclick="loadModel()">â†“ Download & Run Model</button>
    </div>
    <div id="progress-box">
      <div class="prog-row">
        <span id="prog-label">Downloading...</span>
        <span id="prog-pct">0%</span>
      </div>
      <div class="prog-track"><div class="prog-fill" id="prog-fill"></div></div>
    </div>
  </div>

  <div id="mode-bar">
    <span class="mode-label">Mode</span>
    <button class="mode-btn active" id="mode-chat" onclick="setMode('chat')">ğŸ’¬ Chat</button>
    <button class="mode-btn" id="mode-math" onclick="setMode('math')">ğŸ”¢ Math</button>
    <button class="mode-btn" id="mode-code" onclick="setMode('code')">ğŸ’» Code</button>
    <button class="mode-btn" id="mode-creative" onclick="setMode('creative')">âœ¨ Creative</button>
    <div class="mode-sep"></div>
    <button class="clear-btn" onclick="clearChat()">â†º Reset</button>
  </div>

  <div id="chat-area">
    <div id="messages">
      <div id="empty-state">
        <div class="empty-glyph">ğŸ§ </div>
        <div class="empty-title">Ready â€” pick a mode or start typing</div>
        <div class="empty-hint">Press ğŸ“š to load a PDF/TXT into Memory Base Â· ğŸŒ for Wikipedia</div>
        <div class="suggestion-chips" id="chips"></div>
      </div>
    </div>

    <div id="input-area">
      <div class="input-shell" id="input-shell">
        <textarea id="user-input" placeholder="Message Smol Architect..." rows="1"
          onkeydown="handleKey(event)" oninput="autoResize(this)"></textarea>
        <!-- Web toggle -->
        <button class="icon-btn web-toggle" id="web-toggle" onclick="toggleWeb()">
          ğŸŒ
          <span class="tip">Web search: OFF</span>
        </button>
        <!-- Memory toggle -->
        <button class="icon-btn memory-toggle" id="memory-toggle-btn" onclick="openMemoryPanel()">
          ğŸ“š
          <span class="tip">Memory Base</span>
        </button>
        <button class="stop-btn" id="stop-btn" onclick="stopGeneration()" title="Stop generation">â– </button>
        <button class="send-btn" id="send-btn" onclick="sendMessage()">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
            <line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/>
          </svg>
        </button>
      </div>
      <div class="input-footer">
        <span class="input-hint">Enter to send Â· Shift+Enter for newline</span>
        <div class="right-hints">
          <span class="gen-indicator" id="gen-indicator">â— generating</span>
          <span class="web-on-label" id="web-on-label">ğŸŒ web on</span>
          <span class="mem-on-label" id="mem-on-label">ğŸ“š memory on</span>
          <span class="temp-display">temp: <span id="temp-label">0.72</span></span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- â”€â”€ MEMORY PANEL â”€â”€ -->
<div id="memory-panel">
  <div class="panel-header">
    <div class="panel-title">ğŸ“š Memory Base</div>
    <button class="panel-close" onclick="closeMemoryPanel()">âœ•</button>
  </div>
  <div class="panel-body">
    <!-- Drop zone -->
    <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-input').click()"
      ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
      <div class="drop-zone-icon">ğŸ“„</div>
      <div class="drop-zone-label"><strong>Click to upload</strong> or drag & drop</div>
      <div class="drop-zone-sub">Supports .pdf and .txt files</div>
    </div>
    <input type="file" id="file-input" accept=".pdf,.txt" multiple onchange="handleFileSelect(event)">

    <!-- Processing progress -->
    <div id="mem-progress">
      <div class="mem-prog-row">
        <span id="mem-prog-label">Processing...</span>
        <span id="mem-prog-pct">0%</span>
      </div>
      <div class="mem-prog-track"><div class="mem-prog-fill" id="mem-prog-fill"></div></div>
    </div>

    <!-- Stats -->
    <div id="mem-stats"></div>

    <!-- Doc list -->
    <div class="doc-list" id="doc-list">
      <div class="panel-empty" id="doc-empty">No documents loaded yet.<br>Upload a PDF or TXT and the model<br>will use it to answer your questions.</div>
    </div>

    <!-- Clear all -->
    <button class="clear-mem-btn" id="clear-mem-btn" style="display:none" onclick="clearMemory()">âœ• Clear all documents</button>
  </div>
</div>

<div id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script type="module">

// â”€â”€ PDF.js worker â”€â”€
if (typeof pdfjsLib !== 'undefined') {
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
}

// â”€â”€ Config â”€â”€
const WLLAMA_VER  = "2.3.0";
const WLLAMA_CDNS = [
  `https://esm.sh/@wllama/wllama@${WLLAMA_VER}`,
  `https://cdn.jsdelivr.net/npm/@wllama/wllama@${WLLAMA_VER}/dist`
];
const MODEL_URL   = "https://huggingface.co/Trapside/Trapside/resolve/main/Smol_Architect_Elite_v4.gguf";
const MAX_CTX     = 2048;
const HISTORY_TURNS = 10;

// â”€â”€ Memory Base config â”€â”€
const CHUNK_SIZE     = 400;   // chars per chunk (~100 tokens)
const CHUNK_OVERLAP  = 80;    // overlap between chunks
const TOP_K_CHUNKS   = 4;     // how many chunks to inject
const MEM_CTX_LIMIT  = 1400;  // max chars of memory context injected

// â”€â”€ State â”€â”€
let wllama = null;
let generating = false;
let currentMode = 'chat';
let webSearchOn = false;
let history = [];
let lastAiMsgEl = null;
let shouldStop = false;

// â”€â”€ Memory Base state â”€â”€
// memoryDocs: [{ id, name, type, chunkCount, chunks: [{text, docName}] }]
let memoryDocs  = [];
let memoryChunks = []; // flat array of all chunks across all docs

// â”€â”€ Expose globals â”€â”€
window.loadModel        = loadModel;
window.sendMessage      = sendMessage;
window.handleKey        = handleKey;
window.autoResize       = autoResize;
window.setMode          = setMode;
window.clearChat        = clearChat;
window.regenLast        = regenLast;
window.copyMsg          = copyMsg;
window.toggleWeb        = toggleWeb;
window.stopGeneration   = stopGeneration;
window.openMemoryPanel  = openMemoryPanel;
window.closeMemoryPanel = closeMemoryPanel;
window.handleDragOver   = handleDragOver;
window.handleDragLeave  = handleDragLeave;
window.handleDrop       = handleDrop;
window.handleFileSelect = handleFileSelect;
window.removeDoc        = removeDoc;
window.clearMemory      = clearMemory;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MODES = {
  chat: {
    temp: 0.72, top_p: 0.9, top_k: 40, rep_pen: 1.1, maxTokens: 450,
    system: `You are Smol Architect Elite, a helpful, honest, and friendly assistant.
You remember everything said earlier in the conversation and refer back to it naturally.
You answer clearly and concisely. You are warm and never make things up.
If unsure, say so honestly.`,
    placeholder: "Ask me anything...",
    suggestions: ["What is machine learning?", "Tell me a fun space fact", "Explain black holes simply"]
  },
  math: {
    temp: 0.2, top_p: 0.8, top_k: 20, rep_pen: 1.05, maxTokens: 500,
    system: `You are Smol Architect Elite in Math Mode. You are a precise step-by-step math solver.
ALWAYS show working clearly. Label each step (Step 1:, Step 2:, etc.) then state "Answer: X" at the end.
Never skip steps. State assumptions if a problem is ambiguous.`,
    placeholder: "Enter a math problem...",
    suggestions: ["48 cookies, sell 3/4, give 6 away. How many left?", "What is 15% of 240?", "Solve: 2x + 7 = 19"]
  },
  code: {
    temp: 0.25, top_p: 0.85, top_k: 30, rep_pen: 1.08, maxTokens: 600,
    system: `You are Smol Architect Elite in Code Mode. You are a precise Python assistant.
Always use proper syntax, include comments, use descriptive names.
Format code in triple backtick python blocks.
Explain what the code does and why. If debugging: root cause first, then fixed code, then explanation.`,
    placeholder: "Describe a coding problem or paste code to debug...",
    suggestions: ["Write a function to find duplicates in a list", "Explain list comprehensions", "Why does dividing by zero crash Python?"]
  },
  creative: {
    temp: 0.92, top_p: 0.95, top_k: 60, rep_pen: 1.15, maxTokens: 500,
    system: `You are Smol Architect Elite in Creative Mode. You are an imaginative writing assistant.
Be vivid, original, and engaging. Avoid cliches. Surprise the reader.
Commit fully to the creative direction. Use concrete sensory details.`,
    placeholder: "Give me a creative writing prompt...",
    suggestions: ["Story opening: library after midnight", "Explain the internet as a medieval kingdom", "Poem about debugging code"]
  }
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MEMORY BASE â€” FILE PARSING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Chunk raw text into overlapping segments
function chunkText(text, docName) {
  // Normalise whitespace
  const clean = text.replace(/\r\n/g, '\n').replace(/\n{3,}/g, '\n\n').trim();
  const chunks = [];
  let start = 0;
  while (start < clean.length) {
    const end = Math.min(start + CHUNK_SIZE, clean.length);
    let slice = clean.slice(start, end);
    // Try to break at a sentence boundary to keep chunks coherent
    if (end < clean.length) {
      const lastPeriod = Math.max(slice.lastIndexOf('. '), slice.lastIndexOf('.\n'), slice.lastIndexOf('? '), slice.lastIndexOf('! '));
      if (lastPeriod > CHUNK_SIZE * 0.5) {
        slice = clean.slice(start, start + lastPeriod + 1);
      }
    }
    chunks.push({ text: slice.trim(), docName });
    start += slice.length - CHUNK_OVERLAP;
    if (start >= clean.length) break;
  }
  return chunks;
}

async function parseTxt(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => resolve(e.target.result);
    reader.onerror = reject;
    reader.readAsText(file);
  });
}

async function parsePdf(file) {
  if (typeof pdfjsLib === 'undefined') throw new Error('PDF.js not loaded');
  const arrayBuffer = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let fullText = '';
  const total = pdf.numPages;
  for (let i = 1; i <= total; i++) {
    const page    = await pdf.getPage(i);
    const content = await page.getTextContent();
    const pageText = content.items.map(item => item.str).join(' ');
    fullText += pageText + '\n\n';
    // Update progress
    const pct = Math.round((i / total) * 100);
    document.getElementById('mem-prog-fill').style.width = pct + '%';
    document.getElementById('mem-prog-pct').textContent = pct + '%';
    document.getElementById('mem-prog-label').textContent = `Reading page ${i} / ${total}...`;
  }
  return fullText;
}

async function processFile(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  let rawText = '';

  document.getElementById('mem-progress').style.display = 'flex';
  document.getElementById('mem-prog-fill').style.width = '0%';
  document.getElementById('mem-prog-pct').textContent = '0%';
  document.getElementById('mem-prog-label').textContent = 'Reading file...';

  if (ext === 'txt') {
    document.getElementById('mem-prog-fill').style.width = '50%';
    rawText = await parseTxt(file);
    document.getElementById('mem-prog-fill').style.width = '100%';
  } else if (ext === 'pdf') {
    rawText = await parsePdf(file);
  } else {
    throw new Error('Unsupported file type: ' + ext);
  }

  document.getElementById('mem-prog-label').textContent = 'Chunking text...';
  const chunks = chunkText(rawText, file.name);

  document.getElementById('mem-prog-fill').style.width = '100%';
  document.getElementById('mem-prog-pct').textContent = '100%';
  document.getElementById('mem-progress').style.display = 'none';

  return { chunks, charCount: rawText.length };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MEMORY BASE â€” RETRIEVAL
// Simple keyword overlap scoring (TF-style) â€” no embedding model needed.
// Scores each chunk by how many unique query tokens appear in it,
// weighted by rarity across the corpus (basic IDF).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Build a simple stop-word list for noise reduction
const STOP_WORDS = new Set([
  'a','an','the','is','it','in','on','at','to','of','and','or','but','for',
  'with','this','that','are','was','were','be','been','have','has','had',
  'do','does','did','will','would','could','should','may','might','not',
  'from','by','as','if','so','what','how','when','where','who','which',
  'i','you','he','she','we','they','me','him','her','us','them','my','your',
  'his','its','our','their','can','just','also','about','than','then',
  'there','here','all','one','more','some','any','no','up','out','get'
]);

function tokenize(text) {
  return text.toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 2 && !STOP_WORDS.has(w));
}

// Pre-compute IDF weights across the corpus
function buildIDF(chunks) {
  const docFreq = {};
  for (const chunk of chunks) {
    const uniqueTokens = new Set(tokenize(chunk.text));
    for (const t of uniqueTokens) {
      docFreq[t] = (docFreq[t] || 0) + 1;
    }
  }
  const N = chunks.length || 1;
  const idf = {};
  for (const [term, df] of Object.entries(docFreq)) {
    idf[term] = Math.log((N + 1) / (df + 1)) + 1; // smoothed IDF
  }
  return idf;
}

// Score a single chunk against the query using TF-IDF overlap
function scoreChunk(chunkTokens, queryTokens, idf) {
  let score = 0;
  const chunkSet = new Set(chunkTokens);
  for (const qt of queryTokens) {
    if (chunkSet.has(qt)) {
      score += (idf[qt] || 1);
    }
  }
  // Normalise by sqrt of chunk length to avoid favouring very long chunks
  return score / Math.sqrt(chunkTokens.length + 1);
}

function retrieveChunks(query, topK = TOP_K_CHUNKS) {
  if (memoryChunks.length === 0) return [];

  const idf = buildIDF(memoryChunks);
  const qTokens = tokenize(query);
  if (qTokens.length === 0) return [];

  const scored = memoryChunks.map(chunk => ({
    chunk,
    score: scoreChunk(tokenize(chunk.text), qTokens, idf)
  }));

  // Sort descending, keep topK with score > 0
  scored.sort((a, b) => b.score - a.score);
  return scored
    .filter(s => s.score > 0)
    .slice(0, topK)
    .map(s => s.chunk);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MEMORY BASE â€” UI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function openMemoryPanel() {
  document.getElementById('memory-panel').classList.add('open');
}
function closeMemoryPanel() {
  document.getElementById('memory-panel').classList.remove('open');
}

function handleDragOver(e) {
  e.preventDefault();
  document.getElementById('drop-zone').classList.add('drag-over');
}
function handleDragLeave() {
  document.getElementById('drop-zone').classList.remove('drag-over');
}
function handleDrop(e) {
  e.preventDefault();
  document.getElementById('drop-zone').classList.remove('drag-over');
  const files = Array.from(e.dataTransfer.files);
  if (files.length) processFiles(files);
}
function handleFileSelect(e) {
  const files = Array.from(e.target.files);
  if (files.length) processFiles(files);
  e.target.value = '';
}

async function processFiles(files) {
  for (const file of files) {
    const ext = file.name.split('.').pop().toLowerCase();
    if (!['pdf','txt'].includes(ext)) {
      showToast('âš  ' + file.name + ' â€” only PDF and TXT supported');
      continue;
    }
    // Check for duplicate
    if (memoryDocs.find(d => d.name === file.name)) {
      showToast('âš  "' + file.name + '" already loaded');
      continue;
    }
    try {
      const { chunks, charCount } = await processFile(file);
      const id = Date.now() + Math.random();
      memoryDocs.push({ id, name: file.name, type: ext, chunkCount: chunks.length, charCount });
      memoryChunks.push(...chunks);
      renderDocList();
      updateMemoryUI();
      showToast('ğŸ“š Loaded: ' + file.name + ' â€” ' + chunks.length + ' chunks');
    } catch (err) {
      console.error(err);
      document.getElementById('mem-progress').style.display = 'none';
      showToast('âŒ Failed to parse ' + file.name + ': ' + err.message);
    }
  }
}

function removeDoc(id) {
  const doc = memoryDocs.find(d => d.id === id);
  if (!doc) return;
  memoryDocs = memoryDocs.filter(d => d.id !== id);
  memoryChunks = memoryChunks.filter(c => c.docName !== doc.name);
  renderDocList();
  updateMemoryUI();
  showToast('ğŸ—‘ Removed: ' + doc.name);
}

function clearMemory() {
  memoryDocs = [];
  memoryChunks = [];
  renderDocList();
  updateMemoryUI();
  showToast('Memory Base cleared');
}

function renderDocList() {
  const list  = document.getElementById('doc-list');
  const empty = document.getElementById('doc-empty');
  const clearBtn = document.getElementById('clear-mem-btn');

  if (memoryDocs.length === 0) {
    list.innerHTML = '';
    list.appendChild(empty || (() => {
      const d = document.createElement('div');
      d.className = 'panel-empty';
      d.id = 'doc-empty';
      d.innerHTML = 'No documents loaded yet.<br>Upload a PDF or TXT and the model<br>will use it to answer your questions.';
      return d;
    })());
    clearBtn.style.display = 'none';
    return;
  }

  list.innerHTML = '';
  clearBtn.style.display = 'block';

  for (const doc of memoryDocs) {
    const el = document.createElement('div');
    el.className = 'doc-item';
    const icon = doc.type === 'pdf' ? 'ğŸ“•' : 'ğŸ“„';
    const kb = (doc.charCount / 1024).toFixed(1);
    el.innerHTML =
      '<div class="doc-icon">' + icon + '</div>' +
      '<div class="doc-info">' +
        '<div class="doc-name"></div>' +
        '<div class="doc-meta">' + doc.chunkCount + ' chunks Â· ' + kb + ' KB</div>' +
      '</div>' +
      '<button class="doc-remove" title="Remove">âœ•</button>';
    el.querySelector('.doc-name').textContent = doc.name;
    el.querySelector('.doc-remove').onclick = () => removeDoc(doc.id);
    list.appendChild(el);
  }
}

function updateMemoryUI() {
  const hasDoc = memoryChunks.length > 0;
  const badge  = document.getElementById('memory-badge');
  const memBtn = document.getElementById('memory-toggle-btn');
  const memLabel = document.getElementById('mem-on-label');
  const stats  = document.getElementById('mem-stats');

  badge.classList.toggle('active', hasDoc);
  document.getElementById('memory-badge-text').textContent = memoryChunks.length + ' chunks';

  memBtn.classList.toggle('has-docs', hasDoc);
  memLabel.classList.toggle('show', hasDoc);

  if (hasDoc) {
    const totalKb = (memoryChunks.reduce((a, c) => a + c.text.length, 0) / 1024).toFixed(1);
    stats.style.display = 'block';
    stats.textContent = 'ğŸ“š ' + memoryDocs.length + ' doc' + (memoryDocs.length > 1 ? 's' : '') +
      ' Â· ' + memoryChunks.length + ' chunks Â· ' + totalKb + ' KB indexed';
  } else {
    stats.style.display = 'none';
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSuggestions() {
  const chips = document.getElementById('chips');
  if (!chips) return;
  chips.innerHTML = '';
  MODES[currentMode].suggestions.forEach(s => {
    const c = document.createElement('button');
    c.className = 'chip';
    c.textContent = s;
    c.onclick = () => { document.getElementById('user-input').value = s; sendMessage(); };
    chips.appendChild(c);
  });
}
renderSuggestions();

function toggleWeb() {
  webSearchOn = !webSearchOn;
  const btn   = document.getElementById('web-toggle');
  const label = document.getElementById('web-on-label');
  const shell = document.getElementById('input-shell');
  const tip   = btn.querySelector('.tip');
  if (webSearchOn) {
    btn.classList.add('on');
    shell.classList.add('web-mode');
    label.classList.add('show');
    tip.textContent = 'Web search: ON';
    showToast('ğŸŒ Web search ON');
  } else {
    btn.classList.remove('on');
    shell.classList.remove('web-mode');
    label.classList.remove('show');
    tip.textContent = 'Web search: OFF';
    showToast('Web search OFF');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WEB SEARCH
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function fetchWebContext(query) {
  try {
    const searchURL = 'https://en.wikipedia.org/w/api.php?' + new URLSearchParams({
      action: 'query', list: 'search', srsearch: query,
      srlimit: '3', format: 'json', origin: '*'
    });
    const searchRes = await fetch(searchURL);
    if (!searchRes.ok) throw new Error('Wikipedia search failed');
    const searchData = await searchRes.json();
    const results = searchData?.query?.search;
    if (!results || results.length === 0) return null;

    const topTitle = results[0].title;
    const summaryURL = 'https://en.wikipedia.org/api/rest_v1/page/summary/' + encodeURIComponent(topTitle);
    const summaryRes = await fetch(summaryURL);
    if (!summaryRes.ok) throw new Error('Wikipedia summary failed');
    const summaryData = await summaryRes.json();
    const extract = summaryData?.extract;
    if (!extract || extract.length < 30) return null;

    const extraSnippets = results.slice(1, 3)
      .map(r => r.snippet.replace(/<[^>]+>/g, '').trim())
      .filter(s => s.length > 20).join('\n\n');
    const fullContext = extract + (extraSnippets ? '\n\nRelated:\n' + extraSnippets : '');

    return {
      context: fullContext.substring(0, 1200),
      sources: [
        { title: topTitle, url: 'https://en.wikipedia.org/wiki/' + encodeURIComponent(topTitle.replace(/ /g, '_')) },
        ...results.slice(1, 3).map(r => ({
          title: r.title,
          url: 'https://en.wikipedia.org/wiki/' + encodeURIComponent(r.title.replace(/ /g, '_'))
        }))
      ]
    };
  } catch (err) {
    console.error('Web search error:', err);
    return null;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MODE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setMode(mode) {
  currentMode = mode;
  const cfg = MODES[mode];
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active','math','code','creative'));
  const btn = document.getElementById('mode-' + mode);
  btn.classList.add('active');
  if (mode !== 'chat') btn.classList.add(mode);
  document.getElementById('user-input').placeholder = cfg.placeholder;
  document.getElementById('temp-label').textContent = cfg.temp;
  renderSuggestions();
  showToast('Mode: ' + mode.charAt(0).toUpperCase() + mode.slice(1) + ' â€” temp ' + cfg.temp);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LOAD MODEL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadModel() {
  const btn        = document.getElementById('load-btn');
  const box        = document.getElementById('progress-box');
  const badge      = document.getElementById('status-badge');
  const statusText = document.getElementById('status-text');

  btn.disabled = true;
  btn.textContent = 'Initializing...';
  box.style.display = 'flex';
  badge.className = 'status-badge loading';
  statusText.textContent = 'Loading...';

  let Wllama = null;
  for (const base of WLLAMA_CDNS) {
    try {
      const mod = await import(base + '/src/index.js');
      Wllama = mod.Wllama;
      if (Wllama) break;
    } catch (e) { console.warn('CDN failed:', base, e); }
  }

  if (!Wllama) {
    badge.className = 'status-badge error';
    statusText.textContent = 'Error';
    btn.disabled = false;
    btn.textContent = 'â†º Retry';
    showToast('Could not load wllama â€” check your network/firewall');
    return;
  }

  try {
    const base = WLLAMA_CDNS[0];
    const config = {
      'single-thread/wllama.js':        base + '/src/single-thread/wllama.js',
      'single-thread/wllama.wasm':      base + '/src/single-thread/wllama.wasm',
      'multi-thread/wllama.js':         base + '/src/multi-thread/wllama.js',
      'multi-thread/wllama.wasm':       base + '/src/multi-thread/wllama.wasm',
      'multi-thread/wllama.worker.mjs': base + '/src/multi-thread/wllama.worker.mjs',
    };
    wllama = new Wllama(config);
    statusText.textContent = 'Downloading...';

    await wllama.loadModelFromUrl(MODEL_URL, {
      progressCallback: ({ loaded, total }) => {
        const pct = total > 0 ? Math.round((loaded / total) * 100) : 0;
        document.getElementById('prog-fill').style.width = pct + '%';
        document.getElementById('prog-pct').textContent = pct + '%';
        const mb  = (loaded / 1024 / 1024).toFixed(0);
        const tot = (total  / 1024 / 1024).toFixed(0);
        document.getElementById('prog-label').textContent = `Downloading... ${mb} / ${tot} MB`;
      },
      n_ctx: MAX_CTX,
      n_threads: navigator.hardwareConcurrency || 4,
    });

    document.getElementById('load-screen').style.display = 'none';
    document.getElementById('mode-bar').style.display = 'flex';
    document.getElementById('chat-area').style.display = 'flex';
    document.getElementById('token-display').style.display = 'block';
    badge.className = 'status-badge ready';
    statusText.textContent = 'Ready';
    document.getElementById('user-input').focus();
    updateTokenDisplay();
  } catch (err) {
    console.error(err);
    badge.className = 'status-badge error';
    statusText.textContent = 'Error';
    btn.disabled = false;
    btn.textContent = 'â†º Retry';
    showToast('Failed to load model â€” check console');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TOKEN DISPLAY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function estimateTokens(t) { return Math.ceil(t.length / 3.8); }
function getHistoryTokens() {
  let n = 0;
  for (const m of history) n += estimateTokens(m.content);
  return n;
}
function updateTokenDisplay() {
  const el   = document.getElementById('token-display');
  const used = getHistoryTokens();
  const pct  = used / MAX_CTX;
  el.textContent = used + ' / ' + MAX_CTX + ' tokens';
  el.className = 'token-display';
  if (pct > 0.85) el.classList.add('danger');
  else if (pct > 0.65) el.classList.add('warn');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FIX 1: Prompt injection protection
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPECIAL_TOKEN_RE = /<\|im_(start|end)\|>/g;
function sanitizeForPrompt(text) {
  return text.replace(SPECIAL_TOKEN_RE, '').replace(/\u0000/g, '');
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BUILD PROMPT
// Injects memory context and/or web context as separate turns.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildPrompt(sanitizedUserText, webContext, memContext) {
  const cfg = MODES[currentMode];

  let prompt = '<|im_start|>system\n' + cfg.system + '<|im_end|>\n';

  // Conversation history
  const turns = history.slice(-(HISTORY_TURNS * 2));
  for (const m of turns) {
    prompt += '<|im_start|>' + m.role + '\n' + m.content + '<|im_end|>\n';
  }

  // Memory Base context â€” injected as a separate turn before the user message
  if (memContext) {
    prompt +=
      '<|im_start|>user\n' +
      '[MEMORY BASE â€” The following is relevant content retrieved from the user\'s uploaded documents. ' +
      'Use it as your primary source to answer the next question. ' +
      'If the memory context answers it, lead with that and refine with your own knowledge. ' +
      'If it is not directly relevant, rely on your own knowledge instead.]\n' +
      memContext +
      '<|im_end|>\n' +
      '<|im_start|>assistant\nUnderstood. I have the document context and will use it to answer.<|im_end|>\n';
  }

  // Web context
  if (webContext) {
    prompt +=
      '<|im_start|>user\n' +
      '[WEB CONTEXT â€” Wikipedia information to supplement your answer.]\n' +
      webContext +
      '<|im_end|>\n' +
      '<|im_start|>assistant\nUnderstood. I have the web context.<|im_end|>\n';
  }

  prompt += '<|im_start|>user\n' + sanitizedUserText + '<|im_end|>\n';
  prompt += '<|im_start|>assistant\n';

  return prompt;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SEND
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function sendMessage() {
  if (generating || !wllama) return;
  const input = document.getElementById('user-input');
  const raw   = input.value.trim();
  if (!raw) return;

  input.value = '';
  input.style.height = 'auto';
  document.getElementById('send-btn').disabled = true;

  const es = document.getElementById('empty-state');
  if (es) es.remove();

  const safe = sanitizeForPrompt(raw);

  addMessage('user', raw);
  history.push({ role: 'user', content: safe });
  updateTokenDisplay();
  await generate(safe);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// STOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stopGeneration() {
  if (!generating) return;
  shouldStop = true;
  showToast('â¹ Generation stopped');
}

function setGeneratingUI(isGenerating) {
  const sendBtn = document.getElementById('send-btn');
  const stopBtn = document.getElementById('stop-btn');
  const genInd  = document.getElementById('gen-indicator');
  const shell   = document.getElementById('input-shell');
  if (isGenerating) {
    sendBtn.style.display = 'none';
    stopBtn.classList.add('visible');
    genInd.classList.add('show');
    shell.classList.add('generating');
  } else {
    sendBtn.style.display = 'flex';
    sendBtn.disabled = false;
    stopBtn.classList.remove('visible');
    genInd.classList.remove('show');
    shell.classList.remove('generating');
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GENERATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function generate(sanitizedText) {
  generating = true;
  shouldStop = false;
  setGeneratingUI(true);

  const cfg  = MODES[currentMode];
  const aiEl = addMessage('ai', null, true);
  lastAiMsgEl = aiEl;
  const bubble = aiEl.querySelector('.bubble');
  bubble.innerHTML = '';

  // â”€â”€ Determine context sources active â”€â”€
  const hasMemory = memoryChunks.length > 0;
  const tagMode   = webSearchOn ? 'web' : (hasMemory ? 'memory' : currentMode);
  const tag = document.createElement('div');
  tag.className = 'mode-tag ' + tagMode;
  tag.textContent = webSearchOn ? 'ğŸŒ web' : (hasMemory ? 'ğŸ“š memory' : currentMode);
  bubble.appendChild(tag);

  let webResult = null;
  let memContext = null;
  let matchedChunks = [];

  // â”€â”€ Memory Retrieval â”€â”€
  if (hasMemory) {
    const memBar = document.createElement('div');
    memBar.className = 'web-status searching';
    memBar.textContent = 'ğŸ“š Searching memory base...';
    bubble.appendChild(memBar);
    scrollBottom();

    matchedChunks = retrieveChunks(sanitizedText, TOP_K_CHUNKS);

    if (matchedChunks.length > 0) {
      // Build the memory context block, respecting the char limit
      let ctxText = '';
      for (const chunk of matchedChunks) {
        const section = `[From: ${chunk.docName}]\n${chunk.text}\n\n`;
        if (ctxText.length + section.length > MEM_CTX_LIMIT) break;
        ctxText += section;
      }
      memContext = ctxText.trim();

      memBar.className = 'web-status memory-hit';
      memBar.textContent = 'âœ“ Found ' + matchedChunks.length + ' relevant passage' +
        (matchedChunks.length > 1 ? 's' : '') + ' in memory base';

      // Show which docs were matched
      const matchedDocs = [...new Set(matchedChunks.map(c => c.docName))];
      const row = document.createElement('div');
      row.className = 'sources-row';
      matchedDocs.forEach(name => {
        const chip = document.createElement('span');
        chip.className = 'memory-source-chip';
        chip.textContent = 'ğŸ“š ' + name;
        row.appendChild(chip);
      });
      bubble.appendChild(row);
    } else {
      memBar.className = 'web-status memory-miss';
      memBar.textContent = 'â—‹ Nothing relevant in memory â€” using model knowledge';
    }
  }

  // â”€â”€ Web Search â”€â”€
  if (webSearchOn) {
    const bar = document.createElement('div');
    bar.className = 'web-status searching';
    bar.textContent = 'ğŸ” Searching Wikipedia for: "' + sanitizedText.substring(0, 50) +
      (sanitizedText.length > 50 ? '...' : '') + '"';
    bubble.appendChild(bar);
    scrollBottom();

    webResult = await fetchWebContext(sanitizedText);

    if (webResult && webResult.context) {
      bar.className = 'web-status found';
      bar.textContent = 'âœ“ Wikipedia context found';
      if (webResult.sources && webResult.sources.length > 0) {
        const row = document.createElement('div');
        row.className = 'sources-row';
        webResult.sources.forEach(s => {
          const a = document.createElement('a');
          a.className = 'source-chip';
          a.href = s.url; a.target = '_blank'; a.rel = 'noopener noreferrer';
          a.textContent = 'â†— ' + s.title;
          row.appendChild(a);
        });
        bubble.appendChild(row);
      }
    } else {
      bar.className = 'web-status failed';
      bar.textContent = 'âš  No Wikipedia results â€” using model knowledge only';
    }
  }

  const textNode = document.createElement('span');
  bubble.appendChild(textNode);

  const dots = document.createElement('div');
  dots.className = 'typing';
  dots.innerHTML = '<span></span><span></span><span></span>';
  bubble.appendChild(dots);

  try {
    const prompt   = buildPrompt(sanitizedText, webResult ? webResult.context : null, memContext);
    let fullText = '';

    await wllama.createCompletion(prompt, {
      nPredict: cfg.maxTokens,
      sampling: {
        temp:           cfg.temp,
        top_p:          cfg.top_p,
        top_k:          cfg.top_k,
        penalty_repeat: cfg.rep_pen,
      },
      onNewToken: (_token, _piece, currentText) => {
        fullText = currentText;
        if (dots.parentNode) dots.remove();
        textNode.textContent = currentText;
        scrollBottom();
        if (shouldStop) return false;
      },
    });

    const finalText = fullText.trim() || '(no response â€” try rephrasing)';
    textNode.textContent = finalText;
    history.push({ role: 'assistant', content: shouldStop ? finalText + ' [stopped]' : finalText });
    updateTokenDisplay();

  } catch (err) {
    if (!shouldStop) {
      console.error(err);
      textNode.textContent = 'Generation error â€” check console.';
      showToast('Error during generation');
    }
  } finally {
    generating = false;
    shouldStop = false;
    setGeneratingUI(false);
    if (dots.parentNode) dots.remove();
    document.getElementById('user-input').focus();
    scrollBottom();
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REGEN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function regenLast() {
  if (generating || !wllama) return;
  if (history.length > 0 && history[history.length - 1].role === 'assistant') history.pop();
  const userMsg = history.length > 0 && history[history.length - 1].role === 'user'
    ? history[history.length - 1].content : '';
  if (lastAiMsgEl && lastAiMsgEl.parentNode) {
    lastAiMsgEl.remove();
  } else {
    const msgs  = document.getElementById('messages');
    const allAI = msgs.querySelectorAll('.msg.ai');
    if (allAI.length > 0) allAI[allAI.length - 1].remove();
  }
  lastAiMsgEl = null;
  if (userMsg) await generate(userMsg);
}

function copyMsg(btn) {
  const span = btn.closest('.msg').querySelector('.bubble span');
  if (span) {
    navigator.clipboard.writeText(span.textContent);
    btn.textContent = 'copied!';
    setTimeout(() => { btn.textContent = 'copy'; }, 1200);
  }
}

function clearChat() {
  history = [];
  lastAiMsgEl = null;
  document.getElementById('messages').innerHTML = `
    <div id="empty-state">
      <div class="empty-glyph">ğŸ§ </div>
      <div class="empty-title">Conversation cleared â€” start fresh</div>
      <div class="empty-hint">Press ğŸ“š to load documents Â· ğŸŒ for Wikipedia</div>
      <div class="suggestion-chips" id="chips"></div>
    </div>`;
  renderSuggestions();
  updateTokenDisplay();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addMessage(role, text, typing) {
  const msgs = document.getElementById('messages');
  const el   = document.createElement('div');
  el.className = 'msg ' + role;
  const now  = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

  if (typing) {
    el.innerHTML =
      '<div class="av">ğŸ§ </div>' +
      '<div class="msg-wrap"><div class="bubble"></div>' +
      '<div class="msg-meta"><span>' + now + '</span>' +
      '<div class="msg-actions">' +
        '<button class="action-btn regen" onclick="regenLast()">â†º regen</button>' +
        '<button class="action-btn" onclick="copyMsg(this)">copy</button>' +
      '</div></div></div>';
  } else {
    const av = role === 'user' ? 'ğŸ‘¤' : 'ğŸ§ ';
    el.innerHTML =
      '<div class="av">' + av + '</div>' +
      '<div class="msg-wrap"><div class="bubble"></div>' +
      '<div class="msg-meta"><span>' + now + '</span></div></div>';
    el.querySelector('.bubble').textContent = text;
  }

  msgs.appendChild(el);
  scrollBottom();
  return el;
}

function scrollBottom() { const m = document.getElementById('messages'); m.scrollTop = m.scrollHeight; }
function handleKey(e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); } }
function autoResize(el) { el.style.height = 'auto'; el.style.height = Math.min(el.scrollHeight, 130) + 'px'; }
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2800);
}

</script>
</body>
</html>
