<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>SmolLM2 — Low Power Primary</title>

  <script type="importmap">
    { "imports": { "@mlc-ai/web-llm": "https://esm.run/@mlc-ai/web-llm" } }
  </script>

  <style>
    /* UI: clean, mobile-friendly, lightweight */
    :root{
      --bg1:#e6efff; --bg2:#f4f7fb; --primary:#007AFF; --accent:#5856D6; --muted:#8e8e93; --card:rgba(255,255,255,0.92);
    }
    html,body{height:100%;margin:0;font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(160deg,var(--bg1),var(--bg2));-webkit-font-smoothing:antialiased}
    .card{width:94%;max-width:470px;margin:4vh auto;height:92vh;background:var(--card);border-radius:18px;display:flex;flex-direction:column;overflow:hidden;padding-top:env(safe-area-inset-top);box-shadow:0 8px 30px rgba(6,10,18,0.06)}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(0,0,0,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.95), transparent)}
    .title{font-weight:700;color:#0b1220}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(0,0,0,0.06);padding:6px 10px;border-radius:12px;font-size:13px;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,0.6)}
    .btn--danger{color:#ff3b30;border-color:rgba(255,59,48,0.12)}
    .toggle{display:inline-flex;align-items:center;gap:8px;font-size:13px;cursor:pointer}
    .toggle input{width:40px;height:22px;appearance:none;background:#e9eef;border-radius:11px;position:relative;outline:none;cursor:pointer}
    .toggle input:after{content:"";position:absolute;left:3px;top:3px;width:16px;height:16px;border-radius:8px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,0.06);transition:transform 160ms ease}
    .toggle input:checked{background:linear-gradient(90deg,var(--primary),var(--accent))}
    .toggle input:checked:after{transform:translateX(18px)}
    main#chat{flex:1;overflow:auto;padding:14px;display:flex;flex-direction:column;gap:12px;background:transparent}
    .msg{max-width:78%;padding:10px 14px;border-radius:16px;word-break:break-word;font-size:15px;line-height:1.35;box-shadow:0 6px 14px rgba(11,17,24,0.04)}
    .user{align-self:flex-end;background:linear-gradient(180deg,var(--primary),#005bd8);color:#fff;border-bottom-right-radius:6px}
    .assistant{align-self:flex-start;background:#fff;color:#0b1220;border-bottom-left-radius:6px}
    .muted{font-size:12px;color:var(--muted)}
    .input-row{display:flex;padding:10px;gap:8px;border-top:1px solid rgba(0,0,0,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.95), transparent)}
    input[type="text"]{flex:1;padding:12px;border-radius:18px;border:1px solid #e9eef;font-size:15px;background:#fff}
    button#send{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;border:none;padding:10px 14px;border-radius:14px;cursor:pointer;box-shadow:0 6px 18px rgba(0,122,255,0.12)}
    button:disabled{opacity:0.5;cursor:not-allowed}

    /* overlay + modal (first-time only) */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(8,12,20,0.12);z-index:60;padding:20px}
    .progressModal{width:88%;max-width:420px;background:var(--card);border-radius:12px;padding:14px;text-align:center;box-shadow:0 12px 40px rgba(6,10,18,0.12)}
    .progressBar{height:8px;background:#eee;border-radius:8px;overflow:hidden;margin-top:12px}
    .progressBar > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--primary),var(--accent));transition:width 120ms linear}

    /* traits modal */
    .traitsModal{width:92%;max-width:420px;background:var(--card);border-radius:12px;padding:12px;box-shadow:0 12px 40px rgba(6,10,18,0.12)}
    .trait-chips{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .chip{background:#f3f6ff;border:1px solid rgba(0,0,0,0.03);padding:6px 10px;border-radius:999px;font-size:13px}
    .traitsEditor{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .traitsEditor input{padding:8px;border-radius:8px;border:1px solid #eee}
    .modalActions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}

    /* thinking pulsing animation */
    @keyframes pulse {
      0% { opacity: 0.6; transform: translateY(0); }
      50% { opacity: 1; transform: translateY(-2px); }
      100% { opacity: 0.6; transform: translateY(0); }
    }
    .thinking { font-style:italic;color:var(--muted);padding:8px 12px;border-radius:12px;background:transparent;border:1px dashed rgba(0,0,0,0.04);max-width:78%; animation: pulse 1.2s ease-in-out infinite }

    .fade-in { animation: fadeIn 360ms ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px);} to { opacity: 1; transform: translateY(0); } }

    @media (max-width:360px){
      .card{width:98%;height:94vh}
      .msg{font-size:14px}
    }
  </style>
</head>
<body>
  <div class="card" id="card">
    <!-- overlay used for first-time download ONLY -->
    <div class="overlay" id="overlay" aria-hidden="true">
      <div class="progressModal" id="progressModal" role="status" aria-live="polite">
        <div style="font-weight:600" id="overlayTitle">Preparing model…</div>
        <div class="muted" id="overlaySub">Optimized for low-memory devices</div>
        <div class="progressBar" aria-hidden="true"><i id="overlayBar"></i></div>
      </div>
    </div>

    <header>
      <div class="title">SmolLM2</div>
      <div class="controls">
        <!-- Low Power toggle (kept, default ON) -->
        <label class="toggle" title="Low Power Mode">
          <input id="lowPowerToggle" type="checkbox" />
        </label>

        <button class="btn" id="traitsBtn">Traits</button>
        <button class="btn btn--danger" id="resetBtn">Reset</button>
      </div>
    </header>

    <main id="chat" aria-live="polite" aria-atomic="false">
      <!-- content filled by script -->
    </main>

    <div class="input-row">
      <input id="userInput" type="text" placeholder="Ask me anything..." autocomplete="off" />
      <button id="send">Send</button>
    </div>
  </div>

  <!-- Traits Editor Overlay -->
  <div class="overlay" id="traitsOverlay" aria-hidden="true">
    <div class="traitsModal" role="dialog" aria-modal="true" aria-labelledby="traitsTitle">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div id="traitsTitle" style="font-weight:700">User Traits (max 7)</div>
        <div class="muted" id="traitsCount">0/7</div>
      </div>

      <div class="trait-chips" id="traitsChips" aria-hidden="false"></div>

      <div class="traitsEditor" id="traitsEditor"></div>

      <div class="modalActions">
        <button class="btn" id="addTraitBtn">+ Add</button>
        <button class="btn" id="saveTraitsBtn">Save</button>
        <button class="btn" id="cancelTraitsBtn">Cancel</button>
      </div>

      <div class="muted" style="margin-top:8px">Low Power mode injects fewer traits and limits history to reduce memory use.</div>
    </div>
  </div>

  <script type="module">
    import * as webllm from "@mlc-ai/web-llm";

    // Config and caps (tuned for SmolLM2-360M, with reasoning/formatting improvements)
    const MODEL_ID = "SmolLM2-360M-Instruct-q4f16_1-MLC";
    const MAX_TRAITS = 7;
    const LOWPOWER_TRAITS = 3;
    const HISTORY_TURNS_LOW = 2;
    const REPLY_CHAR_CAP_LOW = 800;
    const SYSTEM_PROMPT_CHAR_CAP = 900;
    const TRAITS_KEY = 'smollm_user_traits_v1';
    const LOWPOWER_KEY = 'smollm_lowpower_v1';
    const MODEL_DOWNLOADED_KEY = 'smollm_model_downloaded_v1';
    const REASONING_CACHE_KEY = 'smollm_reasoning_cache_v1';
    const MAX_MESSAGES_IN_DOM = 8;
    const ALL_MESSAGES_STORE_CAP = 500;
    const MAX_RESET_RETRIES = 1;

    // UI refs
    const chat = document.getElementById('chat');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('send');
    const resetBtn = document.getElementById('resetBtn');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlaySub = document.getElementById('overlaySub');
    const overlayBar = document.getElementById('overlayBar');
    const lowPowerToggle = document.getElementById('lowPowerToggle');
    const traitsBtn = document.getElementById('traitsBtn');

    // modal refs
    const traitsOverlay = document.getElementById('traitsOverlay');
    const traitsEditor = document.getElementById('traitsEditor');
    const traitsChips = document.getElementById('traitsChips');
    const addTraitBtn = document.getElementById('addTraitBtn');
    const saveTraitsBtn = document.getElementById('saveTraitsBtn');
    const cancelTraitsBtn = document.getElementById('cancelTraitsBtn');
    const traitsCount = document.getElementById('traitsCount');

    // state
    let userTraits = [];
    function loadLowPowerRaw(){ try { return localStorage.getItem(LOWPOWER_KEY); } catch { return null; } }
    function loadLowPower(){ try { return localStorage.getItem(LOWPOWER_KEY) === '1'; } catch { return false; } }
    function saveLowPower(v){ try { localStorage.setItem(LOWPOWER_KEY, v ? '1' : '0'); } catch {} }

    let lowPower = true;
    let history = [];
    let engine = null;
    const requestQueue = [];
    let processing = false;

    // windowed message rendering
    const allMessages = [];
    let displayStart = 0;
    const MESSAGE_WINDOW = MAX_MESSAGES_IN_DOM;
    let userIsNearBottom = true;

    (function wireChatScroll() {
      chat.addEventListener('scroll', () => {
        const near = (chat.scrollTop + chat.clientHeight) >= (chat.scrollHeight - 80);
        userIsNearBottom = near;
      }, { passive: true });
    })();

    function renderMessageWindow() {
      chat.innerHTML = '';

      if (displayStart > 0) {
        const loadBtn = document.createElement('button');
        loadBtn.className = 'btn';
        loadBtn.textContent = 'Load earlier';
        loadBtn.style.margin = '6px 0';
        loadBtn.addEventListener('click', () => {
          displayStart = Math.max(0, displayStart - MESSAGE_WINDOW);
          renderMessageWindow();
          requestAnimationFrame(() => { chat.scrollTop = 1; });
        });
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.justifyContent = 'center';
        wrapper.appendChild(loadBtn);
        chat.appendChild(wrapper);
      }

      const end = Math.min(allMessages.length, displayStart + MESSAGE_WINDOW);
      for (let i = displayStart; i < end; i++) {
        const m = allMessages[i];
        const d = document.createElement('div');
        d.className = (m.className ? m.className + ' ' : '') + 'msg ' + (m.role === 'user' ? 'user' : 'assistant');
        d.textContent = m.text;
        chat.appendChild(d);
      }

      if ((displayStart + MESSAGE_WINDOW) < allMessages.length) {
        const newerBtn = document.createElement('button');
        newerBtn.className = 'btn';
        newerBtn.textContent = 'Load newer';
        newerBtn.style.margin = '6px 0';
        newerBtn.addEventListener('click', () => {
          const maxStart = Math.max(0, allMessages.length - MESSAGE_WINDOW);
          displayStart = Math.min(maxStart, displayStart + MESSAGE_WINDOW);
          renderMessageWindow();
          requestAnimationFrame(() => { chat.scrollTop = chat.scrollHeight; });
        });
        const wrapper2 = document.createElement('div');
        wrapper2.style.display = 'flex';
        wrapper2.style.justifyContent = 'center';
        wrapper2.appendChild(newerBtn);
        chat.appendChild(wrapper2);
      }

      if (userIsNearBottom) {
        requestAnimationFrame(() => { chat.scrollTop = chat.scrollHeight; });
      }
    }

    function appendMessageWindowed(role, text, opts = {}) {
      const entry = { role, text, className: opts.className || '' };
      allMessages.push(entry);

      if (allMessages.length > ALL_MESSAGES_STORE_CAP) {
        allMessages.shift();
        if (displayStart > 0) displayStart = Math.max(0, displayStart - 1);
      }

      const showingTail = (displayStart + MESSAGE_WINDOW) >= (allMessages.length - 1);
      if (showingTail) {
        displayStart = Math.max(0, allMessages.length - MESSAGE_WINDOW);
      } else {
        if (allMessages.length <= MESSAGE_WINDOW) displayStart = 0;
      }

      renderMessageWindow();
    }
    const appendMessage = appendMessageWindowed;

    function clampString(s, maxChars){
      if(!s) return '';
      if(s.length <= maxChars) return s;
      return s.slice(0, maxChars - 3) + '...';
    }

    // overlay
    let lastOverlayProgress = -1;
    function showOverlay(title='Preparing model…', sub='Optimizing for low-memory', progress=0){
      const p = Math.max(0, Math.min(1, progress));
      if (Math.abs(p - lastOverlayProgress) < 0.02 && overlay.style.display === 'flex') {
        overlayTitle.textContent = title;
        overlaySub.textContent = sub;
        return;
      }
      lastOverlayProgress = p;
      overlayTitle.textContent = title;
      overlaySub.textContent = sub;
      overlayBar.style.width = `${Math.round(p * 100)}%`;
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
    }
    function hideOverlay(){ overlay.style.display = 'none'; overlay.setAttribute('aria-hidden', 'true'); overlayBar.style.width = '0%'; lastOverlayProgress = -1; }

    // engine creation with progress
    async function createEngineWithProgress() {
      const alreadyDownloaded = modelDownloadedFlag();
      let downloadObserved = false;

      const eng = await webllm.CreateMLCEngine(MODEL_ID, {
        initProgressCallback: (report) => {
          const p = Math.max(0, Math.min(1, (report && report.progress) || 0));
          const text = (report && report.text) || '';

          if (!alreadyDownloaded) {
            if (p < 1) {
              downloadObserved = true;
              showOverlay(text || 'Downloading model…', 'This happens only once on this device', p);
            } else {
              if (downloadObserved) setModelDownloadedFlag();
              hideOverlay();
            }
          }
        }
        // intentionally leaving other engine options to defaults for portability
      });

      return eng;
    }

    // persistence helpers
    function loadTraits(){ try { const r = localStorage.getItem(TRAITS_KEY); return r ? JSON.parse(r).slice(0,MAX_TRAITS) : []; } catch { return []; } }
    function saveTraits(arr){ try { localStorage.setItem(TRAITS_KEY, JSON.stringify((arr||[]).slice(0,MAX_TRAITS))); } catch {} }
    function modelDownloadedFlag(){ try { return localStorage.getItem(MODEL_DOWNLOADED_KEY) === '1'; } catch { return false; } }
    function setModelDownloadedFlag(){ try { localStorage.setItem(MODEL_DOWNLOADED_KEY, '1'); } catch {} }

    function loadReasoningCache(){
      try {
        const raw = localStorage.getItem(REASONING_CACHE_KEY);
        if (!raw) return {};
        const obj = JSON.parse(raw);
        return obj && typeof obj === 'object' ? obj : {};
      } catch { return {}; }
    }
    function saveReasoningCache(cache){
      try {
        const keys = Object.keys(cache || {});
        if (keys.length > 200) {
          keys.sort((a,b) => cache[a].t - cache[b].t);
          for (let i=0;i<keys.length-200;i++) delete cache[keys[i]];
        }
        localStorage.setItem(REASONING_CACHE_KEY, JSON.stringify(cache));
      } catch {}
    }
    function getCachedReasoning(key){ const c = loadReasoningCache(); return c[key] ? c[key].v : null; }
    function setCachedReasoning(key, value){ const c = loadReasoningCache(); c[key] = { v: value, t: Date.now() }; saveReasoningCache(c); }

    // Simple stable hash for cache keys (djb2)
    function stableHash(s){
      let h = 5381;
      for (let i=0;i<s.length;i++) h = ((h << 5) + h) + s.charCodeAt(i);
      return (h >>> 0).toString(36);
    }

    // Improved system prompt: strong formatting + refusal for chain-of-thought
    function buildSystemPrompt(){
      const traits = userTraits.slice(0, LOWPOWER_TRAITS);
      const compact = traits.map(t => t.replace(/\s+/g, ' ').trim()).filter(Boolean).join(' | ');
      const instructions = [
        "You are a concise assistant specialized for short, accurate answers.",
        "OUTPUT RULES: Produce ONLY a single line that starts with 'Answer:' followed by the concise answer. Do NOT give explanations, chain-of-thought, steps, or any extra text.",
        "If you cannot determine a reliable answer, respond exactly: 'Answer: I don't know.'",
        "Keep the answer short (<= 60 words). Prefer to be brief and precise.",
        "Do not include uncertainty percentages, confidence, or meta commentary."
      ].join(' ');
      const base = "Concise assistant. Keep replies short and precise.";
      const systemRaw = compact ? `${base} User: ${compact}. ${instructions}` : `${base} ${instructions}`;
      return clampString(systemRaw, SYSTEM_PROMPT_CHAR_CAP);
    }

    // Build messages with small-history support (useful for SmolLM2)
    function buildMessages(userText){
      const system = buildSystemPrompt();
      const recent = [];
      // include last N turns from history when not in strict low-power mode,
      // or include HISTORY_TURNS_LOW when lowPower is false/true as configured.
      const turns = lowPower ? HISTORY_TURNS_LOW : Math.max(HISTORY_TURNS_LOW, 4);
      if (turns > 0) {
        // history contains alternating user/assistant entries; take last turns*2 entries
        const sliceSize = turns * 2;
        const tail = history.slice(-sliceSize);
        for (const h of tail) recent.push(h);
      }
      recent.push({ role: 'user', content: userText });
      return [{ role: 'system', content: system }, ...recent];
    }

    // Extract Answer: robust parsing
    function extractAnswer(fullText) {
      if (!fullText) return '';
      // try explicit "Answer:" capture
      const answerMatch = fullText.match(/Answer\s*:\s*([\s\S]*?)(?:\n|$)/i);
      if (answerMatch && answerMatch[1].trim()) return answerMatch[1].trim();
      // fallback: take first non-empty line and treat as the answer (trim to 250 chars)
      const lines = fullText.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
      if (lines.length) return lines[0].slice(0, 1000);
      return fullText.trim().slice(0, 1000);
    }

    // If model produces extra text, re-run a tiny formatter step to enforce "Answer:" line
    async function formatToSingleLine(answerSource, tryCount = 0) {
      // Avoid recursion: do not call formatter more than once
      try {
        const probe = await createEngineWithProgress();
        const sys = "Formatter: Extract the single concise answer from the provided content. Output ONLY one line that starts with 'Answer:' followed by the answer. If none present or unsure, output 'Answer: I don't know.'";
        const messages = [{ role: 'system', content: sys }, { role: 'user', content: answerSource }];
        // Use a short synchronous completion (stream => false) if API supports it; fallback to streaming.
        try {
          const chunks = await probe.chat.completions.create({ messages, stream: true });
          let out = '';
          for await (const c of chunks) {
            out += c?.choices?.[0]?.delta?.content || '';
            if (out.length > 400) break;
          }
          try { await probe.unload(); } catch(e){}
          return out.trim();
        } catch (streamErr) {
          // last-resort: try single-shot call (some runtimes support non-stream)
          try {
            const res = await probe.chat.completions.create({ messages });
            const text = (res?.choices?.[0]?.message?.content) || '';
            try { await probe.unload(); } catch(e){}
            return text.trim();
          } catch (e) {
            try { await probe.unload(); } catch(e){}
            return null;
          }
        }
      } catch (err) {
        console.warn('formatToSingleLine failed', err);
        return null;
      }
    }

    // small helper to detect trivial outputs
    function isTrivial(text) {
      if (!text) return true;
      const t = text.trim();
      if (/^(high|medium|low)$/i.test(t)) return true;
      if (t.length <= 3 && /^[A-Za-z]{1,3}$/.test(t)) return true;
      return false;
    }

    // aggressive reset and retry (unchanged mostly)
    async function aggressiveResetAndRetry(originalUserText) {
      appendMessage('assistant', 'Trying to refresh my mind...');
      sendBtn.disabled = true;
      requestQueue.length = 0;
      try { while (chat.children.length > 2) chat.removeChild(chat.firstChild); } catch (e) {}
      try { if (engine && typeof engine.unload === 'function') await engine.unload(); } catch (e) {}
      engine = null;
      await new Promise(resolve => setTimeout(resolve, 600));
      try { localStorage.removeItem(REASONING_CACHE_KEY); } catch(e){}
      try {
        const probe = await createEngineWithProgress();
        try { if (probe && typeof probe.unload === 'function') await probe.unload(); } catch(e) {}
        appendMessage('assistant', 'I refreshed successfully. Retrying your question...');
        await new Promise(resolve => setTimeout(resolve, 300));
        if (originalUserText && originalUserText.trim()) {
          await handleSingleRequest(originalUserText, /*retriesLeft*/ 0);
        }
        sendBtn.disabled = false;
        return true;
      } catch (probeErr) {
        appendMessage('assistant', 'I could not refresh fully. Performing a quick page refresh to free memory...');
        setTimeout(() => {
          try { window.location.reload(); } catch (reloadErr) {
            appendMessage('assistant', 'Automatic reload failed. Please manually refresh the page.');
            sendBtn.disabled = false;
          }
        }, 700);
        return false;
      }
    }

    // Recovery direct answer (unchanged)
    async function recoveryDirectAnswer(userText) {
      try {
        const eng = await createEngineWithProgress();
        const sys = "Concise assistant. Provide a single-line direct answer to the user's question. Do NOT include 'Certainty' or steps — just the answer. Output exactly one line starting with 'Answer:'. If unsure, output 'Answer: I don't know.'";
        const messages = [{ role: 'system', content: sys }, { role: 'user', content: userText }];
        const chunks = await eng.chat.completions.create({ messages, stream: true });
        let text = '';
        for await (const chunk of chunks) {
          const delta = chunk?.choices?.[0]?.delta?.content || '';
          if (delta) {
            text += delta;
            if (text.length > REPLY_CHAR_CAP_LOW) {
              text = text.slice(0, REPLY_CHAR_CAP_LOW) + '\n\n[truncated]';
              break;
            }
          }
        }
        try { await eng.unload(); } catch(e){}
        return text.trim();
      } catch (err) {
        console.warn('Direct recovery failed', err);
        return null;
      }
    }

    // handle a single user request: improved flow -> cache -> engine -> enforce Answer: format -> cache result
    async function handleSingleRequest(userText, retriesLeft = MAX_RESET_RETRIES) {
      if (!userText || !userText.trim()) return;
      const normQ = userText.trim();
      const cacheKey = stableHash(normQ);
      const cached = getCachedReasoning(cacheKey);
      if (cached) {
        appendMessage('assistant', cached);
        return;
      }

      // thinking placeholder
      appendMessage('assistant', 'Thinking...', { className: 'thinking' });

      const alreadyDownloaded = modelDownloadedFlag();
      if (!alreadyDownloaded) {
        showOverlay('Preparing engine…', 'First-time model download may take longer', 0);
        await new Promise(requestAnimationFrame);
      } else {
        await new Promise(requestAnimationFrame);
      }

      sendBtn.disabled = true;
      let localEngine = null;
      let fullReply = '';

      try {
        const messages = buildMessages(normQ);
        localEngine = await createEngineWithProgress();
        engine = localEngine;

        const chunks = await localEngine.chat.completions.create({ messages, stream: true });
        for await (const chunk of chunks) {
          const delta = chunk?.choices?.[0]?.delta?.content || '';
          if (delta) {
            fullReply += delta;
            if (fullReply.length > REPLY_CHAR_CAP_LOW) {
              fullReply = fullReply.slice(0, REPLY_CHAR_CAP_LOW) + '\n\n[truncated to fit device limits]';
              break;
            }
            // yield occasionally for UI responsiveness
            if (fullReply.length % 200 === 0) await new Promise(requestAnimationFrame);
          }
        }

        try { await localEngine.unload(); } catch(e) { console.warn('error unloading after stream', e); }
        engine = null;
        localEngine = null;

        hideOverlay();

        // If model didn't follow "Answer:" format, try to enforce formatting with a small formatting pass
        let finalLine = '';
        if (/Answer\s*:/i.test(fullReply)) {
          finalLine = 'Answer: ' + extractAnswer(fullReply);
        } else {
          // attempt formatter pass to strictly produce "Answer:" line
          const fmt = await formatToSingleLine(fullReply, 0);
          if (fmt && /Answer\s*:/i.test(fmt)) {
            finalLine = fmt.split(/\r?\n/).find(l => /Answer\s*:/i.test(l)).trim();
          } else {
            // fallback: extract best-effort and prefix Answer:
            const best = extractAnswer(fullReply);
            finalLine = best ? `Answer: ${best}` : `Answer: I don't know.`;
          }
        }

        // small sanity: if trivial or empty, try a direct recovery attempt once
        if ((isTrivial(finalLine) || !finalLine || finalLine.length < 6) && retriesLeft > 0) {
          const direct = await recoveryDirectAnswer(normQ);
          if (direct && /Answer\s*:/i.test(direct) && !isTrivial(direct)) {
            finalLine = direct;
          }
        }

        // Remove 'Thinking...' placeholder
        for (let i = 0; i < allMessages.length; i++) {
          if (allMessages[i] && allMessages[i].text === 'Thinking...' && allMessages[i].className && allMessages[i].className.includes('thinking')) {
            allMessages.splice(i, 1);
            if (displayStart > 0) displayStart = Math.max(0, displayStart - 1);
            break;
          }
        }
        // append final answer (strip extra whitespace)
        finalLine = (finalLine || 'Answer: I don\'t know.').trim();
        appendMessage('assistant', finalLine);

        // store in history and cache (cache stores the final single-line string)
        history.push({ role: 'user', content: normQ }, { role: 'assistant', content: finalLine });
        const maxEntries = HISTORY_TURNS_LOW * 2;
        if (maxEntries > 0 && history.length > maxEntries) history = history.slice(-maxEntries);
        if (maxEntries === 0) history = [];

        try { setCachedReasoning(cacheKey, finalLine); } catch(e) {}

      } catch (err) {
        console.error('Inference error', err);
        // remove placeholder if exists
        for (let i = allMessages.length - 1; i >= 0; i--) {
          if (allMessages[i] && allMessages[i].text === 'Thinking...') {
            allMessages.splice(i, 1);
            break;
          }
        }
        try { if (localEngine) await localEngine.unload(); } catch(e){}
        engine = null;
        localEngine = null;
        hideOverlay();

        if (retriesLeft > 0) {
          await aggressiveResetAndRetry(userText);
        } else {
          appendMessage('assistant', 'Answer: I don\'t know.');
        }
      } finally {
        sendBtn.disabled = false;
      }
    }

    // queueing
    function queueRequest(userText){
      if (!userText || !userText.trim()) return;
      appendMessage('user', userText);
      requestQueue.push({ userText });
      processQueue();
    }

    async function processQueue(){
      if (processing) return;
      processing = true;
      while (requestQueue.length) {
        const req = requestQueue.shift();
        await handleSingleRequest(req.userText);
        await new Promise(resolve => setTimeout(resolve, 120));
      }
      processing = false;
    }

    // UI wiring
    sendBtn.addEventListener('click', () => {
      const txt = userInput.value.trim();
      if (!txt) return;
      userInput.value = '';
      queueRequest(txt);
    });
    userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendBtn.click(); } });

    // reset
    resetBtn.addEventListener('click', async () => {
      history = [];
      allMessages.length = 0;
      displayStart = 0;
      renderMessageWindow();
      appendMessage('assistant', 'Ready. Memory purged.');
      requestQueue.length = 0;
      try { if (engine) await engine.unload(); } catch(e) {}
      engine = null;
      try { localStorage.removeItem(REASONING_CACHE_KEY); } catch(e){}
    });

    // low-power default handling
    const lowPowerRaw = loadLowPowerRaw();
    if (lowPowerRaw === null) {
      lowPower = true;
      saveLowPower(true);
    } else {
      lowPower = loadLowPower();
    }
    lowPowerToggle.checked = lowPower;
    lowPowerToggle.addEventListener('change', (e) => {
      lowPower = !!e.target.checked;
      saveLowPower(lowPower);
      appendMessage('assistant', lowPower ? 'Low Power enabled.' : 'Low Power disabled.');
    });

    // traits editor
    function openTraits(){ renderTraitsModal(); traitsOverlay.style.display = 'flex'; traitsOverlay.setAttribute('aria-hidden','false'); }
    function closeTraits(){ traitsOverlay.style.display = 'none'; traitsOverlay.setAttribute('aria-hidden','true'); }

    function renderTraitsModal(){
      traitsEditor.innerHTML = '';
      traitsChips.innerHTML = '';
      userTraits.forEach((t, idx) => {
        const chip = document.createElement('div'); chip.className = 'chip'; chip.textContent = t; traitsChips.appendChild(chip);
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
        const input = document.createElement('input'); input.value = t; input.placeholder = `Trait ${idx+1}`;
        input.addEventListener('input', () => userTraits[idx] = input.value);
        const rm = document.createElement('button'); rm.className = 'btn'; rm.textContent = 'Remove';
        rm.addEventListener('click', () => { userTraits.splice(idx,1); renderTraitsModal(); });
        row.appendChild(input); row.appendChild(rm);
        traitsEditor.appendChild(row);
      });
      traitsCount.textContent = `${userTraits.length}/${MAX_TRAITS}`;
    }

    addTraitBtn.addEventListener('click', () => {
      if (userTraits.length >= MAX_TRAITS) return;
      userTraits.push('');
      renderTraitsModal();
    });
    saveTraitsBtn.addEventListener('click', () => {
      userTraits = userTraits.map(s => (s || '').trim()).filter(Boolean).slice(0, MAX_TRAITS);
      saveTraits(userTraits);
      closeTraits();
      appendMessage('assistant', 'Traits saved.');
    });
    cancelTraitsBtn.addEventListener('click', () => closeTraits());
    traitsBtn.addEventListener('click', () => openTraits());

    // initial load of traits and ready message
    userTraits = loadTraits();
    if (!userTraits || !userTraits.length) {
      userTraits = ['Concise','English'];
      saveTraits(userTraits);
    }

    appendMessage('assistant', 'Ready. Running SmolLM2-360M (Low Power primary).');
    try { userInput.focus(); } catch(e){}
  </script>
</body>
</html>
